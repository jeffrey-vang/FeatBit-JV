import { defaultReactOptions } from "./types";
import camelCase from "lodash.camelcase";
export default function getFlagsProxy(fbClient, bootstrapFlags, fetchedFlags, reactOptions) {
    if (reactOptions === void 0) { reactOptions = defaultReactOptions; }
    var _a = reactOptions.useCamelCaseFlagKeys, useCamelCaseFlagKeys = _a === void 0 ? false : _a, _b = reactOptions.sendEventsOnFlagRead, sendEventsOnFlagRead = _b === void 0 ? true : _b;
    var _c = useCamelCaseFlagKeys ? getCamelizedKeysAndFlagMap(fetchedFlags) : [fetchedFlags], flags = _c[0], _d = _c[1], flagKeyMap = _d === void 0 ? {} : _d;
    return {
        flags: toFlagsProxy(fbClient, bootstrapFlags, flags, flagKeyMap, fetchedFlags, useCamelCaseFlagKeys, sendEventsOnFlagRead),
        flagKeyMap: flagKeyMap,
    };
}
function getCamelizedKeysAndFlagMap(rawFlags) {
    var flags = {};
    var flagKeyMap = {};
    for (var rawFlagKey in rawFlags) {
        // Exclude system keys
        if (rawFlagKey.indexOf('$') === 0) {
            continue;
        }
        var camelKey = camelCase(rawFlagKey);
        flags[camelKey] = rawFlags[rawFlagKey];
        flagKeyMap[camelKey] = rawFlagKey;
    }
    return [flags, flagKeyMap];
}
function hasFlag(flags, flagKey) {
    return Object.prototype.hasOwnProperty.call(flags, flagKey);
}
function toFlagsProxy(fbClient, bootstrapFlags, flags, flagKeyMap, flagsWithRawFlagKeys, useCamelCaseFlagKeys, sendEventsOnFlagRead) {
    return new Proxy(flags, {
        get: function (target, prop, receiver) {
            var currentValue = Reflect.get(target, prop, receiver) || flagsWithRawFlagKeys[prop];
            // check if flag key exists as camelCase or original case
            var validFlagKey = hasFlag(flagKeyMap, prop) || hasFlag(target, prop) || hasFlag(flagsWithRawFlagKeys, prop);
            if (!validFlagKey && hasFlag(bootstrapFlags, prop)) {
                return bootstrapFlags[prop];
            }
            // only process flag keys and ignore symbols and native Object functions
            if (typeof prop === 'symbol' || !validFlagKey) {
                return currentValue;
            }
            if (useCamelCaseFlagKeys && prop !== camelCase(prop)) {
                console.warn("You're attempting to access a flag with its original keyId: ".concat(prop, ", even though useCamelCaseFlagKeys is set to true."));
            }
            if (currentValue === undefined) {
                return undefined;
            }
            if (!sendEventsOnFlagRead) {
                return currentValue;
            }
            var pristineFlagKey = useCamelCaseFlagKeys ? (flagKeyMap[prop] || prop) : prop;
            return fbClient.variation(pristineFlagKey, currentValue);
        },
    });
}
//# sourceMappingURL=getFlagsProxy.js.map