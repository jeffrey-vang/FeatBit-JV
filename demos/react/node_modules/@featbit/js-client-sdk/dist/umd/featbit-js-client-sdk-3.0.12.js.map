{"version":3,"file":"featbit-js-client-sdk-3.0.12.js","mappings":"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","sources":["webpack://@featbit/js-client-sdk/webpack/universalModuleDefinition","webpack://@featbit/js-client-sdk/./src/Configuration.ts","webpack://@featbit/js-client-sdk/./src/Context.ts","webpack://@featbit/js-client-sdk/./src/FbClientBuilder.ts","webpack://@featbit/js-client-sdk/./src/FbClientCore.ts","webpack://@featbit/js-client-sdk/./src/bootstrap/JsonBootstrapProvider.ts","webpack://@featbit/js-client-sdk/./src/bootstrap/NullBootstrapProvider.ts","webpack://@featbit/js-client-sdk/./src/bootstrap/index.ts","webpack://@featbit/js-client-sdk/./src/constants.ts","webpack://@featbit/js-client-sdk/./src/data-sources/DataSourceUpdates.ts","webpack://@featbit/js-client-sdk/./src/data-sources/createStreamListeners.ts","webpack://@featbit/js-client-sdk/./src/data-sources/index.ts","webpack://@featbit/js-client-sdk/./src/data-sync/DataSyncMode.ts","webpack://@featbit/js-client-sdk/./src/data-sync/NullDataSynchronizer.ts","webpack://@featbit/js-client-sdk/./src/data-sync/PollingDataSynchronizer.ts","webpack://@featbit/js-client-sdk/./src/data-sync/Requestor.ts","webpack://@featbit/js-client-sdk/./src/data-sync/WebSocketDataSynchronizer.ts","webpack://@featbit/js-client-sdk/./src/data-sync/index.ts","webpack://@featbit/js-client-sdk/./src/data-sync/types.ts","webpack://@featbit/js-client-sdk/./src/data-sync/utils.ts","webpack://@featbit/js-client-sdk/./src/errors.ts","webpack://@featbit/js-client-sdk/./src/evaluation/EvalResult.ts","webpack://@featbit/js-client-sdk/./src/evaluation/Evaluator.ts","webpack://@featbit/js-client-sdk/./src/evaluation/ReasonKinds.ts","webpack://@featbit/js-client-sdk/./src/evaluation/data/IFlag.ts","webpack://@featbit/js-client-sdk/./src/evaluation/data/index.ts","webpack://@featbit/js-client-sdk/./src/evaluation/index.ts","webpack://@featbit/js-client-sdk/./src/events/DefaultEventProcessor.ts","webpack://@featbit/js-client-sdk/./src/events/DefaultEventQueue.ts","webpack://@featbit/js-client-sdk/./src/events/DefaultEventSender.ts","webpack://@featbit/js-client-sdk/./src/events/DefaultEventSerializer.ts","webpack://@featbit/js-client-sdk/./src/events/EventDispatcher.ts","webpack://@featbit/js-client-sdk/./src/events/IEventSender.ts","webpack://@featbit/js-client-sdk/./src/events/NullEventProcessor.ts","webpack://@featbit/js-client-sdk/./src/events/event.ts","webpack://@featbit/js-client-sdk/./src/events/index.ts","webpack://@featbit/js-client-sdk/./src/index.ts","webpack://@featbit/js-client-sdk/./src/logging/BasicLogger.ts","webpack://@featbit/js-client-sdk/./src/logging/SafeLogger.ts","webpack://@featbit/js-client-sdk/./src/logging/format.ts","webpack://@featbit/js-client-sdk/./src/logging/index.ts","webpack://@featbit/js-client-sdk/./src/options/ClientContext.ts","webpack://@featbit/js-client-sdk/./src/options/OptionMessages.ts","webpack://@featbit/js-client-sdk/./src/options/UserBuilder.ts","webpack://@featbit/js-client-sdk/./src/options/Validators.ts","webpack://@featbit/js-client-sdk/./src/options/index.ts","webpack://@featbit/js-client-sdk/./src/platform/browser/BrowserInfo.ts","webpack://@featbit/js-client-sdk/./src/platform/browser/BrowserPlatform.ts","webpack://@featbit/js-client-sdk/./src/platform/browser/BrowserRequests.ts","webpack://@featbit/js-client-sdk/./src/platform/browser/BrowserWebSocket.ts","webpack://@featbit/js-client-sdk/./src/platform/browser/FbClient.ts","webpack://@featbit/js-client-sdk/./src/platform/browser/LocalStorageStore.ts","webpack://@featbit/js-client-sdk/./src/platform/index.ts","webpack://@featbit/js-client-sdk/./src/store/BaseStore.ts","webpack://@featbit/js-client-sdk/./src/store/DataKinds.ts","webpack://@featbit/js-client-sdk/./src/store/InMemoryStore.ts","webpack://@featbit/js-client-sdk/./src/store/index.ts","webpack://@featbit/js-client-sdk/./src/store/serialization.ts","webpack://@featbit/js-client-sdk/./src/store/store.ts","webpack://@featbit/js-client-sdk/./src/utils/Emits.ts","webpack://@featbit/js-client-sdk/./src/utils/EventEmitter.ts","webpack://@featbit/js-client-sdk/./src/utils/ValueConverters.ts","webpack://@featbit/js-client-sdk/./src/utils/canonicalizeUri.ts","webpack://@featbit/js-client-sdk/./src/utils/debounce.ts","webpack://@featbit/js-client-sdk/./src/utils/http.ts","webpack://@featbit/js-client-sdk/./src/utils/index.ts","webpack://@featbit/js-client-sdk/./src/utils/isNullOrUndefined.ts","webpack://@featbit/js-client-sdk/./src/utils/serializeUser.ts","webpack://@featbit/js-client-sdk/./src/utils/sleep.ts","webpack://@featbit/js-client-sdk/./src/version.ts","webpack://@featbit/js-client-sdk/webpack/bootstrap","webpack://@featbit/js-client-sdk/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, () => {\nreturn ","import { IOptions } from \"./options/IOptions\";\nimport { ILogger } from \"./logging/ILogger\";\nimport { IValidatedOptions } from \"./options/IValidatedOptions\";\nimport { NumberWithMinimum, TypeValidator, TypeValidators, UserValidator } from \"./options/Validators\";\nimport OptionMessages from \"./options/OptionMessages\";\nimport { IStore } from \"./platform/IStore\";\nimport { IClientContext } from \"./options/IClientContext\";\nimport { IDataSynchronizer } from \"./data-sync/IDataSynchronizer\";\nimport { IDataSourceUpdates } from \"./store/IDataSourceUpdates\";\nimport InMemoryStore from \"./store/InMemoryStore\";\nimport { VoidFunction } from \"./utils/VoidFunction\";\nimport { isNullOrUndefined } from \"./utils/isNullOrUndefined\";\nimport { canonicalizeUri } from \"./utils/canonicalizeUri\";\nimport { IBootstrapProvider } from \"./bootstrap/IBootstrapProvider\";\nimport { NullBootstrapProvider } from \"./bootstrap/NullBootstrapProvider\";\nimport { EmptyString } from \"./constants\";\nimport { DataSyncModeEnum } from \"./data-sync/DataSyncMode\";\nimport { IUser } from \"./options/IUser\";\nimport { JsonBootstrapProvider } from \"./bootstrap\";\n\n// Once things are internal to the implementation of the SDK we can depend on\n// types. Calls to the SDK could contain anything without any regard to typing.\n// So, data we take from external sources must be normalized into something\n// that can be trusted.\n\n/**\n * These perform cursory validations. Complex objects are implemented with classes\n * and these should allow for conditional construction.\n */\nconst validations: Record<string, TypeValidator> = {\n  startWaitTime: TypeValidators.Number,\n  sdkKey: TypeValidators.String,\n  pollingUri: TypeValidators.String,\n  streamingUri: TypeValidators.String,\n  eventsUri: TypeValidators.String,\n  webSocketPingInterval: TypeValidators.Number,\n  logger: TypeValidators.Object,\n  store: TypeValidators.ObjectOrFactory,\n  dataSynchronizer: TypeValidators.ObjectOrFactory,\n  flushInterval: TypeValidators.Number,\n  maxEventsInQueue: TypeValidators.Number,\n  pollingInterval: TypeValidators.Number,\n  offline: TypeValidators.Boolean,\n  dataSyncMode: TypeValidators.String,\n  bootstrap: TypeValidators.Bootstrap,\n  user: TypeValidators.User\n};\n\n/**\n * @internal\n */\nexport const defaultValues: IValidatedOptions = {\n  startWaitTime: 5000,\n  sdkKey: '',\n  pollingUri: '',\n  streamingUri: '',\n  eventsUri: '',\n  dataSyncMode: DataSyncModeEnum.STREAMING,\n  sendEvents: true,\n  webSocketPingInterval: 18 * 1000,\n  flushInterval: 2000,\n  maxEventsInQueue: 10000,\n  pollingInterval: 30000,\n  offline: false,\n  store: (options: IOptions) => new InMemoryStore(),\n  bootstrap: undefined,\n  user: undefined,\n};\n\nfunction validateTypesAndNames(options: IOptions): {\n  errors: string[];\n  validatedOptions: IValidatedOptions;\n} {\n  let errors: string[] = [];\n  const validatedOptions: IValidatedOptions = {...defaultValues};\n  Object.keys(options).forEach((optionName) => {\n    // We need to tell typescript it doesn't actually know what options are.\n    // If we don't then it complains we are doing crazy things with it.\n    const optionValue = (options as unknown as any)[optionName];\n    const validator = validations[optionName];\n    if (validator) {\n      if (!validator.is(optionValue)) {\n        if (validator.getType() === 'boolean') {\n          errors.push(OptionMessages.wrongOptionTypeBoolean(optionName, typeof optionValue));\n          validatedOptions[optionName] = !!optionValue;\n        } else if (\n          validator instanceof NumberWithMinimum &&\n          TypeValidators.Number.is(optionValue)\n        ) {\n          const {min} = validator as NumberWithMinimum;\n          errors.push(OptionMessages.optionBelowMinimum(optionName, optionValue, min));\n          validatedOptions[optionName] = min;\n        } else if (validator instanceof UserValidator) {\n          errors = [...errors, ...validator.messages];\n          validatedOptions[optionName] = defaultValues[optionName];\n        } else {\n          errors.push(\n            OptionMessages.wrongOptionType(optionName, validator.getType(), typeof optionValue),\n          );\n          validatedOptions[optionName] = defaultValues[optionName];\n        }\n      } else {\n        validatedOptions[optionName] = optionValue;\n      }\n    } else {\n      options.logger?.warn(OptionMessages.unknownOption(optionName));\n    }\n  });\n  return {errors, validatedOptions};\n}\n\nfunction validateEndpoints(options: IOptions, validatedOptions: IValidatedOptions) {\n  const {streamingUri, pollingUri, eventsUri} = options;\n  const streamingUriMissing = isNullOrUndefined(streamingUri) || streamingUri === EmptyString;\n  const pollingUriMissing = isNullOrUndefined(pollingUri) || pollingUri === EmptyString;\n  const eventsUriMissing = isNullOrUndefined(eventsUri) || eventsUri === EmptyString;\n\n  if (!validatedOptions.offline && (eventsUriMissing || (streamingUriMissing && pollingUriMissing))) {\n    if (eventsUriMissing) {\n      validatedOptions.logger?.error(OptionMessages.partialEndpoint('eventsUri'));\n    }\n\n    if (validatedOptions.dataSyncMode === DataSyncModeEnum.STREAMING && streamingUriMissing) {\n      validatedOptions.logger?.error(OptionMessages.partialEndpoint('streamingUri'));\n    }\n\n    if (validatedOptions.dataSyncMode === DataSyncModeEnum.POLLING && pollingUriMissing) {\n      validatedOptions.logger?.error(OptionMessages.partialEndpoint('pollingUri'));\n    }\n  }\n}\n\nexport default class Configuration {\n  public readonly startWaitTime: number;\n\n  public readonly sdkKey: string;\n\n  public readonly streamingUri: string;\n\n  public readonly pollingUri: string;\n\n  public readonly eventsUri: string;\n\n  public readonly webSocketPingInterval: number;\n\n  public readonly logger?: ILogger;\n\n  public readonly flushInterval: number;\n\n  public readonly maxEventsInQueue: number;\n\n  public readonly pollingInterval: number;\n\n  public readonly offline: boolean;\n\n  public readonly dataSyncMode: DataSyncModeEnum;\n\n  public readonly bootstrapProvider: IBootstrapProvider = new NullBootstrapProvider();\n\n  public user: IUser;\n\n  public readonly storeFactory: (clientContext: IClientContext) => IStore;\n\n  public readonly dataSynchronizerFactory?: (\n    clientContext: IClientContext,\n    store: IStore,\n    dataSourceUpdates: IDataSourceUpdates,\n    initSuccessHandler: VoidFunction,\n    errorHandler?: (e: Error) => void,\n  ) => IDataSynchronizer;\n\n  constructor(options: IOptions = {}) {\n    // The default will handle undefined, but not null.\n    // Because we can be called from JS we need to be extra defensive.\n    options = options || {};\n    // If there isn't a valid logger from the platform, then logs would go nowhere.\n    this.logger = options.logger;\n\n    const {errors, validatedOptions} = validateTypesAndNames(options);\n    errors.forEach((error) => {\n      this.logger?.warn(error);\n    });\n\n    this.user = options.user!;\n\n    validateEndpoints(options, validatedOptions);\n    this.streamingUri = `${ canonicalizeUri(validatedOptions.streamingUri) }/streaming`;\n    this.pollingUri = `${ canonicalizeUri(validatedOptions.pollingUri) }/api/public/sdk/client/latest-all`;\n    this.eventsUri = `${ canonicalizeUri(validatedOptions.eventsUri) }/api/public/insight/track`;\n\n    this.startWaitTime = validatedOptions.startWaitTime;\n\n    this.sdkKey = validatedOptions.sdkKey;\n    this.webSocketPingInterval = validatedOptions.webSocketPingInterval!;\n\n    this.flushInterval = validatedOptions.flushInterval;\n    this.maxEventsInQueue = validatedOptions.maxEventsInQueue;\n    this.pollingInterval = validatedOptions.pollingInterval;\n\n    this.offline = validatedOptions.offline;\n    if (validatedOptions.bootstrap && validatedOptions.bootstrap.length > 0) {\n      try {\n        this.bootstrapProvider = new JsonBootstrapProvider(validatedOptions.bootstrap);\n      } catch (_) {\n        this.logger?.error('Failed to parse bootstrap JSON, use NullBootstrapProvider.');\n      }\n    }\n\n    if (this.offline) {\n      this.logger?.info('Offline mode enabled. No data synchronization with the FeatBit server will occur.');\n    }\n\n    this.dataSyncMode = validatedOptions.dataSyncMode;\n\n    if (TypeValidators.Function.is(validatedOptions.dataSynchronizer)) {\n      // @ts-ignore\n      this.dataSynchronizerFactory = validatedOptions.dataSynchronizer;\n    } else {\n      // The processor is already created, just have the method return it.\n      // @ts-ignore\n      this.dataSynchronizerFactory = () => validatedOptions.dataSynchronizer;\n    }\n\n    if (TypeValidators.Function.is(validatedOptions.store)) {\n      // @ts-ignore\n      this.storeFactory = validatedOptions.store;\n    } else {\n      // The store is already created, just have the method return it.\n      // @ts-ignore\n      this.storeFactory = () => validatedOptions.store;\n    }\n  }\n}","import { IUser } from \"./options/IUser\";\n\nexport default class Context {\n  private _user?: IUser;\n  /**\n   * Is this a valid context. If a valid context cannot be created, then this flag will be true.\n   * The validity of a context should be tested before it is used.\n   */\n  public readonly valid: boolean;\n\n  public readonly message?: string;\n\n  /**\n   * Contexts should be created using the static factory method {@link Context.fromUser}.\n   *\n   * The factory methods are static functions within the class because they access private\n   * implementation details, so they cannot be free functions.\n   */\n  private constructor(valid: boolean, message?: string) {\n    this.valid = valid;\n    this.message = message;\n  }\n\n  public static fromUser(user: IUser): Context {\n    if (!user) {\n      return Context.contextForError('No user specified');\n    }\n\n    const {keyId, name} = user;\n\n    if (keyId === undefined || keyId === null || keyId.trim() === '') {\n      return Context.contextForError('key is mandatory');\n    }\n\n    const context = new Context(true);\n    context._user = user;\n\n    return context;\n  }\n\n  get user(): IUser {\n    return this._user!;\n  }\n\n  get keyId(): string {\n    return this._user!.keyId;\n  }\n\n  value(property: string): any {\n    if (property === 'keyId') {\n      return this._user?.keyId;\n    } else if (property === 'name') {\n      return this._user?.name;\n    } else {\n      return this._user?.customizedProperties?.find(x => x.name === property)?.value;\n    }\n  }\n\n  private static contextForError(message: string) {\n    return new Context(false, message);\n  }\n}","import { IFbClient } from \"./IFbClient\";\nimport { IOptions } from \"./options/IOptions\";\nimport FbClient from \"./platform/browser/FbClient\";\nimport { IDataSynchronizer } from \"./data-sync/IDataSynchronizer\";\nimport { IClientContext } from \"./options/IClientContext\";\nimport { IDataSourceUpdates } from \"./store/IDataSourceUpdates\";\nimport { VoidFunction } from \"./utils/VoidFunction\";\nimport { ILogger } from \"./logging/ILogger\";\nimport { DataSyncModeEnum } from \"./data-sync/DataSyncMode\";\nimport { IUser } from \"./options/IUser\";\nimport { IFlagBase } from \"./evaluation\";\nimport { IPlatform } from \"./platform\";\n\n/**\n * Creates an instance of the FeatBit client.\n *\n * Applications should instantiate a single instance for the lifetime of the application.\n * The client will begin attempting to connect to FeatBit as soon as it is created. To\n * determine when it is ready to use, call {@link IFbClient.waitForInitialization}, or register an\n * event listener for the `\"ready\"` event using {@link IFbClient.on}.\n *\n * **Important:** Do **not** try to instantiate `FbClient` with its constructor\n * (`new FbClientNode()`); the SDK does not currently support\n * this.\n *\n * @return\n *   The new {@link IFbClient} instance.\n */\nexport class FbClientBuilder {\n  private _options: IOptions;\n  private _platform: IPlatform | undefined;\n\n  constructor(options?: IOptions) {\n    this._options = options ?? {};\n  }\n\n  /**\n   * Creates a new instance of the FeatBit client.\n   */\n  build(): IFbClient {\n    return new FbClient(this._options, this._platform);\n  }\n\n  platform(platform: IPlatform | undefined): FbClientBuilder {\n    this._platform = platform;\n    return this;\n  }\n\n  /**\n   * Refer to {@link IOptions.startWaitTime}.\n   */\n  startWaitTime(startWaitTime: number): FbClientBuilder {\n    this._options.startWaitTime = startWaitTime;\n    return this;\n  }\n\n  /**\n   * Refer to {@link IOptions.sdkKey}.\n   */\n  sdkKey(sdkKey: string): FbClientBuilder {\n    this._options.sdkKey = sdkKey;\n    return this;\n  }\n\n  /**\n   * Refer to {@link IOptions.user}.\n   */\n  user(user: IUser): FbClientBuilder {\n    this._options.user = user;\n    return this;\n  }\n\n  /**\n   * Refer to {@link IOptions.streamingUri}.\n   */\n  streamingUri(streamingUri: string): FbClientBuilder {\n    this._options.streamingUri = streamingUri;\n    return this;\n  }\n\n  /**\n   * Refer to {@link IOptions.pollingUri}.\n   */\n  pollingUri(pollingUri: string): FbClientBuilder {\n    this._options.pollingUri = pollingUri;\n    return this;\n  }\n\n  /**\n   * Refer to {@link IOptions.eventsUri}.\n   */\n  eventsUri(eventsUri: string): FbClientBuilder {\n    this._options.eventsUri = eventsUri;\n    return this;\n  }\n\n  /**\n   * Refer to {@link IOptions.dataSyncMode}.\n   */\n  dataSyncMode(mode: DataSyncModeEnum): FbClientBuilder {\n    this._options.dataSyncMode = mode;\n    return this;\n  }\n\n  /**\n   * Refer to {@link IOptions.pollingInterval}.\n   */\n  pollingInterval(pollingInterval: number): FbClientBuilder {\n    this._options.pollingInterval = pollingInterval;\n    return this;\n  }\n\n  /**\n   * Refer to {@link IOptions.flushInterval}.\n   */\n  flushInterval(flushInterval: number): FbClientBuilder {\n    this._options.flushInterval = flushInterval;\n    return this;\n  }\n\n  /**\n   * Refer to {@link IOptions.maxEventsInQueue}.\n   */\n  maxEventsInQueue(maxEventsInQueue: number): FbClientBuilder {\n    this._options.maxEventsInQueue = maxEventsInQueue;\n    return this;\n  }\n\n  /**\n   * Refer to {@link IOptions.logger}.\n   */\n  logger(logger: ILogger): FbClientBuilder {\n    this._options.logger = logger;\n    return this;\n  }\n\n  /**\n   * Refer to {@link IOptions.offline}.\n   */\n  offline(offline: boolean): FbClientBuilder {\n    this._options.offline = offline;\n    return this;\n  }\n\n  /**\n   * Use the JsonBootstrapProvider.\n   */\n  bootstrap(flags: IFlagBase[]): FbClientBuilder {\n    this._options.bootstrap = flags;\n    return this;\n  }\n\n  /**\n   * Refer to {@link IOptions.dataSynchronizer}.\n   */\n  dataSynchronizer(\n    dataSynchronizer: IDataSynchronizer |\n    ((\n      clientContext: IClientContext,\n      dataSourceUpdates: IDataSourceUpdates,\n      initSuccessHandler: VoidFunction,\n      errorHandler?: (e: Error) => void,\n    ) => IDataSynchronizer)\n  ): FbClientBuilder {\n    this._options.dataSynchronizer = dataSynchronizer;\n    return this;\n  }\n}","import { IFbClientCore } from \"./IFbClientCore\";\nimport { IPlatform } from \"./platform/IPlatform\";\nimport Configuration from \"./Configuration\";\nimport { ILogger } from \"./logging/ILogger\";\nimport ClientContext from \"./options/ClientContext\";\nimport DataSourceUpdates from \"./data-sources/DataSourceUpdates\";\nimport { createStreamListeners } from \"./data-sources/createStreamListeners\";\nimport { IEvalDetail } from \"./evaluation/IEvalDetail\";\nimport WebSocketDataSynchronizer from \"./data-sync/WebSocketDataSynchronizer\";\nimport PollingDataSynchronizer from \"./data-sync/PollingDataSynchronizer\";\nimport Requestor from \"./data-sync/Requestor\";\nimport { IDataSynchronizer } from \"./data-sync/IDataSynchronizer\";\nimport DataKinds from \"./store/DataKinds\";\nimport Evaluator from \"./evaluation/Evaluator\";\nimport { ReasonKinds } from \"./evaluation/ReasonKinds\";\nimport { ClientError, TimeoutError } from \"./errors\";\nimport Context from \"./Context\";\nimport { IConvertResult, ValueConverters } from \"./utils/ValueConverters\";\nimport { NullDataSynchronizer } from \"./data-sync/NullDataSynchronizer\";\nimport { IEventProcessor } from \"./events/IEventProcessor\";\nimport { NullEventProcessor } from \"./events/NullEventProcessor\";\nimport { DefaultEventProcessor } from \"./events/DefaultEventProcessor\";\nimport { IStore } from \"./platform/IStore\";\nimport { IOptions } from \"./options/IOptions\";\nimport { MetricEvent } from \"./events/event\";\nimport { DataSyncModeEnum } from \"./data-sync/DataSyncMode\";\nimport { IUser } from \"./options/IUser\";\nimport { UserValidator } from \"./options/Validators\";\n\nenum ClientState {\n  Initializing,\n  Initialized,\n  Failed,\n}\n\nexport interface IClientCallbacks {\n  onError: (err: Error) => void;\n  onFailed: (err: Error) => void;\n  onReady: () => void;\n  // Called whenever flags change, if there are listeners.\n  onUpdate: (keys: string[]) => void;\n  // Method to check if event listeners have been registered.\n  // If none are registered, then onUpdate will never be called.\n  hasEventListeners: () => boolean;\n}\n\nexport class FbClientCore implements IFbClientCore {\n  private state: ClientState = ClientState.Initializing;\n\n  private store?: IStore;\n\n  private dataSynchronizer?: IDataSynchronizer;\n\n  private eventProcessor?: IEventProcessor;\n\n  private evaluator?: Evaluator;\n\n  private initResolve?: (value: IFbClientCore | PromiseLike<IFbClientCore>) => void;\n\n  private initReject?: (err: Error) => void;\n\n  private rejectionReason: Error | undefined;\n\n  private initializedPromise?: Promise<IFbClientCore>;\n\n  private config: Configuration;\n\n  private dataSourceUpdates?: DataSourceUpdates;\n\n  private onError: (err: Error) => void;\n\n  private onFailed: (err: Error) => void;\n\n  private onReady: () => void;\n\n  logger?: ILogger;\n\n  constructor(\n    private options: IOptions,\n    private platform: IPlatform,\n    callbacks: IClientCallbacks\n  ) {\n    this.onError = callbacks.onError;\n    this.onFailed = callbacks.onFailed;\n    this.onReady = callbacks.onReady;\n\n    const {onUpdate, hasEventListeners} = callbacks;\n    const config = new Configuration(options);\n\n    if (!config.sdkKey && !config.offline) {\n      throw new Error('You must configure the client with an SDK key');\n    }\n\n    if (!config.user) {\n      throw new Error('You must configure the client with a user');\n    }\n\n    this.config = config;\n    this.logger = config.logger;\n\n    this.init(onUpdate, hasEventListeners);\n  }\n\n  private async init(onUpdate: (keys: string[]) => void, hasEventListeners: () => boolean) {\n    const clientContext = new ClientContext(this.config.sdkKey, this.config, this.platform);\n    this.store = this.config.storeFactory(clientContext);\n    await this.store.identify(this.config.user);\n    this.dataSourceUpdates = new DataSourceUpdates(this.store, hasEventListeners, onUpdate);\n    this.evaluator = new Evaluator(this.store);\n\n    // use bootstrap provider to populate store\n    await this.config.bootstrapProvider.populate(this.config.user.keyId, this.dataSourceUpdates);\n\n    if (this.config.offline) {\n      this.eventProcessor = new NullEventProcessor();\n      this.dataSynchronizer = new NullDataSynchronizer();\n\n      this.initSuccess();\n    } else {\n      this.eventProcessor = new DefaultEventProcessor(clientContext);\n\n      const listeners = createStreamListeners(this.dataSourceUpdates, this.logger, {\n        put: () => this.initSuccess(),\n        patch: () => this.initSuccess()\n      });\n\n      const dataSynchronizer = this.config.dataSyncMode === DataSyncModeEnum.STREAMING\n        ? new WebSocketDataSynchronizer(\n          this.config.sdkKey,\n          this.config.user,\n          clientContext,\n          this.platform.webSocket,\n          () => this.store!.version,\n          listeners,\n          this.config.webSocketPingInterval\n        )\n        : new PollingDataSynchronizer(\n          this.config,\n          new Requestor(this.config.sdkKey, this.config, this.platform.info, this.platform.requests),\n          () => this.store!.version,\n          listeners,\n          (e) => this.dataSourceErrorHandler(e),\n        );\n\n      this.dataSynchronizer = this.config.dataSynchronizerFactory?.(\n        clientContext,\n        this.store,\n        this.dataSourceUpdates,\n        () => this.initSuccess(),\n        (e) => this.dataSourceErrorHandler(e),\n      ) ?? dataSynchronizer;\n    }\n\n    this.start();\n  }\n\n  async identify(user: IUser) {\n    const validator = new UserValidator();\n    if (!validator.is(user)) {\n      validator.messages.forEach((error: string) => {\n        this.logger?.warn(error);\n      });\n\n      return;\n    }\n\n    const [oldFlags, oldVersion] = this.store!.all(DataKinds.Flags);\n    const oldData = {\n      flags: {...oldFlags},\n      version: oldVersion\n    }\n    this.config.user = user;\n    await this.store!.identify(user);\n    this.dataSynchronizer!.identify(user);\n    const [ newFlags, newVersion ] = this.store!.all(DataKinds.Flags);\n    const newData = {\n      flags: {...newFlags},\n      version: newVersion\n    }\n    if (Object.keys(newFlags).length === 0) {\n      await this.config.bootstrapProvider.populate(user.keyId, this.dataSourceUpdates!);\n    } else {\n      this.dataSourceUpdates?.checkUpdates(oldData, newData);\n    }\n  }\n\n  private start() {\n    if (this.config.offline) {\n      return;\n    }\n\n    this.dataSynchronizer!.start();\n    setTimeout(() => {\n      if (!this.initialized()) {\n        const msg = `FbClient failed to start successfully within ${ this.config.startWaitTime } milliseconds. ` +\n          'This error usually indicates a connection issue with FeatBit or an invalid sdkKey.' +\n          'Please double-check your sdkKey and streamingUri/pollingUri configuration. ' +\n          'We will continue to initialize the FbClient, it still have a chance to get to work ' +\n          'if it\\'s a temporary network issue';\n\n        const error = new TimeoutError(msg);\n        this.state = ClientState.Failed;\n        this.rejectionReason = error;\n        this.initReject?.(error);\n\n        return this.logger?.warn(msg);\n      }\n    }, this.config.startWaitTime);\n  }\n\n  initialized(): boolean {\n    return this.state === ClientState.Initialized;\n  }\n\n  waitForInitialization(): Promise<IFbClientCore> {\n    // An initialization promise is only created if someone is going to use that promise.\n    // If we always created an initialization promise, and there was no call waitForInitialization\n    // by the time the promise was rejected, then that would result in an unhandled promise\n    // rejection.\n\n    // Initialization promise was created by a previous call to waitForInitialization.\n    if (this.initializedPromise) {\n      return this.initializedPromise;\n    }\n\n    // Initialization completed before waitForInitialization was called, so we have completed\n    // and there was no promise. So we make a resolved promise and return it.\n    if (this.state === ClientState.Initialized) {\n      this.initializedPromise = Promise.resolve(this);\n      return this.initializedPromise;\n    }\n\n    // Initialization failed before waitForInitialization was called, so we have completed\n    // and there was no promise. So we make a rejected promise and return it.\n    if (this.state === ClientState.Failed) {\n      this.initializedPromise = Promise.reject(this.rejectionReason);\n      return this.initializedPromise;\n    }\n\n    if (!this.initializedPromise) {\n      this.initializedPromise = new Promise((resolve, reject) => {\n        this.initResolve = resolve;\n        this.initReject = reject;\n      });\n    }\n    return this.initializedPromise;\n  }\n\n  boolVariation(\n    key: string,\n    defaultValue: boolean\n  ): boolean {\n    return this.evaluateCore(key, defaultValue, ValueConverters.bool).value!;\n  }\n\n  boolVariationDetail(\n    key: string,\n    defaultValue: boolean\n  ): IEvalDetail<boolean> {\n    return this.evaluateCore(key, defaultValue, ValueConverters.bool);\n  }\n\n  jsonVariation(key: string, defaultValue: any): any {\n    return this.evaluateCore(key, defaultValue, ValueConverters.json).value!;\n  }\n\n  jsonVariationDetail(key: string, defaultValue: any): IEvalDetail<any> {\n    return this.evaluateCore(key, defaultValue, ValueConverters.json);\n  }\n\n  numberVariation(key: string, defaultValue: number): number {\n    return this.evaluateCore(key, defaultValue, ValueConverters.number).value!;\n  }\n\n  numberVariationDetail(key: string, defaultValue: number): IEvalDetail<number> {\n    return this.evaluateCore(key, defaultValue, ValueConverters.number);\n  }\n\n  stringVariation(key: string, defaultValue: string): string {\n    return this.evaluateCore(key, defaultValue, ValueConverters.string).value!;\n  }\n\n  stringVariationDetail(key: string, defaultValue: string): IEvalDetail<string> {\n    return this.evaluateCore(key, defaultValue, ValueConverters.string);\n  }\n\n  variation(key: string, defaultValue: string): string {\n    return this.evaluateCore(key, defaultValue, ValueConverters.string).value!;\n  }\n\n  variationDetail(key: string, defaultValue: string): IEvalDetail<string> {\n    return this.evaluateCore(key, defaultValue, ValueConverters.string);\n  }\n\n  getAllVariations(): Promise<IEvalDetail<string>[]> {\n    const context = Context.fromUser(this.config.user);\n    if (!context.valid) {\n      const error = new ClientError(\n        `${ context.message ?? 'User not valid;' } returning default value.`,\n      );\n      this.onError(error);\n\n      return Promise.resolve([]);\n    }\n\n    const [flags, _] = this.store!.all(DataKinds.Flags);\n    const result = Object.keys(flags).map(flagKey => {\n      const evalResult = this.evaluator!.evaluate(flagKey);\n      return {flagKey, kind: evalResult.kind, reason: evalResult.reason, value: evalResult.value?.variation};\n    });\n\n    return Promise.resolve(result);\n  }\n\n  async close(): Promise<void> {\n    await this.eventProcessor!.close();\n    this.dataSynchronizer?.close();\n    this.store!.close();\n  }\n\n  track(eventName: string, metricValue?: number | undefined): void {\n    const metricEvent = new MetricEvent(this.config.user, eventName, this.platform.info.appType, metricValue ?? 1);\n    this.eventProcessor!.record(metricEvent);\n    return;\n  }\n\n  async flush(callback?: (res: boolean) => void): Promise<boolean> {\n    try {\n      await this.eventProcessor!.flush();\n      callback?.(true);\n      return true;\n    } catch (err) {\n      callback?.(false);\n      return false;\n    }\n  }\n\n  evaluateCore<TValue>(\n    flagKey: string,\n    defaultValue: TValue,\n    typeConverter: (value: string) => IConvertResult<TValue>\n  ): IEvalDetail<TValue> {\n    const context = Context.fromUser(this.config.user);\n    if (!context.valid) {\n      const error = new ClientError(\n        `${ context.message ?? 'User not valid;' } returning default value.`,\n      );\n      this.onError(error);\n\n      return {flagKey, kind: ReasonKinds.Error, reason: error.message, value: defaultValue};\n    }\n\n    const evalResult = this.evaluator!.evaluate(flagKey);\n\n    if (evalResult.kind === ReasonKinds.FlagNotFound) {\n      // flag not found, return default value\n      const error = new ClientError(evalResult.reason!);\n      this.onError(error);\n\n      return {flagKey, kind: evalResult.kind, reason: evalResult.reason, value: defaultValue};\n    }\n\n    if (!this.initialized()) {\n      this.logger?.warn(\n        'Variation called before FeatBit client initialization completed (did you wait for the' +\n        \"'ready' event?)\",\n      );\n    } else {\n      // send event\n      this.eventProcessor!.record(evalResult.toEvalEvent(this.config.user));\n    }\n\n    const {isSucceeded, value} = typeConverter(evalResult.value?.variation!);\n    return isSucceeded\n      ? {flagKey, kind: evalResult.kind, reason: evalResult.reason, value}\n      : {flagKey, kind: ReasonKinds.WrongType, reason: 'type mismatch', value: defaultValue};\n  }\n\n  private dataSourceErrorHandler(e: any) {\n    const error =\n      e.code === 401 ? new Error('Authentication failed. Double check your SDK key.') : e;\n\n    this.onError(error);\n    this.onFailed(error);\n\n    if (!this.initialized()) {\n      this.state = ClientState.Failed;\n      this.rejectionReason = error;\n      this.initReject?.(error);\n    }\n  }\n\n  private initSuccess() {\n    if (!this.initialized()) {\n      this.state = ClientState.Initialized;\n      this.logger?.info('FbClient started successfully.');\n      this.initResolve?.(this);\n      this.onReady();\n    }\n  }\n}\n","import { IBootstrapProvider } from \"./IBootstrapProvider\";\nimport { deserializeAll } from \"../store/serialization\";\nimport { IDataSourceUpdates } from \"../store/IDataSourceUpdates\";\nimport { IStoreDataStorage } from \"../store/store\";\nimport { isNullOrUndefined } from \"../utils/isNullOrUndefined\";\nimport { IFlag, IFlagBase } from \"../evaluation/data/IFlag\";\n\nexport class JsonBootstrapProvider implements IBootstrapProvider {\n  private dataSet?: IStoreDataStorage;\n\n  constructor(bootstrap: IFlagBase[]) {\n    const flags: IFlag[] = (bootstrap || []).map((flag: IFlagBase) => ({...flag, variationOptions: flag.variationOptions || [{id: null, variation: flag.variation}]})) as IFlag[];\n\n    const data = deserializeAll(flags);\n    this.dataSet = {\n      flags: data.flags,\n      version: 0\n    };\n  }\n\n  populate(userKeyId: string, dataSourceUpdates: IDataSourceUpdates, callback?: () => void): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (isNullOrUndefined(this.dataSet)) {\n        return resolve();\n      }\n\n      const internalCallback = () => {\n        resolve();\n        callback?.();\n      }\n\n      dataSourceUpdates.init(userKeyId, this.dataSet!, internalCallback);\n    });\n  }\n}","import { IBootstrapProvider } from \"./IBootstrapProvider\";\nimport { IDataSourceUpdates } from \"../store/IDataSourceUpdates\";\nimport { IStoreDataStorage } from \"../store/store\";\n\nexport class NullBootstrapProvider implements IBootstrapProvider {\n  private dataSet?: IStoreDataStorage;\n\n  constructor() {\n    this.dataSet = {\n      flags: {},\n      version: 0\n    };\n  }\n\n  populate(userKeyId: string, dataSourceUpdates: IDataSourceUpdates, callback?: () => void): Promise<void> {\n    return new Promise((resolve, reject) => {\n      resolve();\n      callback?.();\n    });\n  }\n}","export * from './IBootstrapProvider';\nexport * from './JsonBootstrapProvider';\nexport * from './NullBootstrapProvider';","export const EmptyString = '';\nexport const MinInt: number = 0x80000000;","import { IDataSourceUpdates } from \"../store/IDataSourceUpdates\";\nimport {\n  IStoreDataStorage,\n  IStoreItem,\n  IKeyedStoreItem\n} from \"../store/store\";\nimport { IStore } from \"../platform/IStore\";\nimport { IDataKind } from \"../IDataKind\";\nimport DataKinds from \"../store/DataKinds\";\n\n/**\n * @internal\n */\nexport default class DataSourceUpdates implements IDataSourceUpdates {\n\n  constructor(\n    private readonly store: IStore,\n    private readonly hasEventListeners: () => boolean,\n    private readonly onChange: (keys: string[]) => void,\n  ) {\n  }\n\n  init(userKeyId: string, allData: IStoreDataStorage, callback?: () => void): void {\n    if (userKeyId !== this.store.user.keyId) {\n      callback?.();\n      return;\n    }\n\n    const checkForChanges = this.hasEventListeners();\n    const doInit = async (oldData?: IStoreDataStorage) => {\n      await this.store.init(allData);\n      Promise.resolve().then(() => {\n        if (checkForChanges) {\n          const updatedKeys = Object.keys(allData)\n            .flatMap((namespace) => {\n              const oldDataForKind = oldData?.[namespace] || {};\n              const newDataForKind = allData[namespace];\n              const mergedData = {...oldDataForKind, ...newDataForKind};\n              return Object.keys(mergedData)\n                .filter((key: string) => this.isUpdated(oldDataForKind && oldDataForKind[key], newDataForKind && newDataForKind[key]));\n            });\n          updatedKeys.length > 0 && this.onChange(updatedKeys);\n        }\n      });\n      callback?.();\n    };\n\n    if (checkForChanges) {\n      const [flags, version] = this.store.all(DataKinds.Flags);\n      const oldData = {\n        flags,\n        version\n      };\n      doInit(oldData);\n    } else {\n      doInit();\n    }\n  }\n\n  checkUpdates(oldData: IStoreDataStorage, newData: IStoreDataStorage, callback?: () => void): void {\n    const checkForChanges = this.hasEventListeners();\n\n    if (!checkForChanges) {\n      return;\n    }\n\n    const updatedKeys = Object.keys(newData)\n    .flatMap((namespace) => {\n      const oldDataForKind = oldData?.[namespace] || {};\n      const newDataForKind = newData[namespace];\n      const mergedData = {...oldDataForKind, ...newDataForKind};\n      return Object.keys(mergedData)\n      .filter((key: string) => this.isUpdated(oldDataForKind && oldDataForKind[key], newDataForKind && newDataForKind[key]));\n    });\n    updatedKeys.length > 0 && this.onChange(updatedKeys);\n\n    callback?.();\n  }\n\n  upsert(userKeyId: string, kind: IDataKind, data: IKeyedStoreItem, callback: () => void): void {\n    if (userKeyId !== this.store.user.keyId) {\n      callback?.();\n      return;\n    }\n\n    const {key} = data;\n    const checkForChanges = this.hasEventListeners();\n    const doUpsert = async (oldItem?: IStoreItem) => {\n      await this.store.upsert(kind, data);\n      Promise.resolve().then(() => {\n        if (checkForChanges && this.isUpdated(oldItem, data[key])) {\n          this.onChange([key]);\n        }\n      });\n\n      callback?.();\n    };\n    if (checkForChanges) {\n      const item = this.store.get(kind, key);\n      doUpsert(item || undefined);\n    } else {\n      doUpsert();\n    }\n  }\n\n  private isUpdated(oldData?: IStoreItem, newData?: IStoreItem): boolean {\n    if (!oldData && !newData) {\n      return false;\n    }\n\n    if (!oldData || !newData) {\n      return true;\n    }\n\n    return newData.version >= oldData.version && newData.variation !== oldData.variation;\n  }\n}","import { IDataSourceUpdates } from \"../store/IDataSourceUpdates\";\nimport { ILogger } from \"../logging/ILogger\";\nimport { VoidFunction } from \"../utils/VoidFunction\";\nimport {\n  deserializeAll,\n  deserializePatch,\n  IPatchData,\n  Flags\n} from \"../store/serialization\";\nimport DataKinds from \"../store/DataKinds\";\nimport { IStoreDataStorage } from \"../store/store\";\nimport { EventName, ProcessStreamResponse } from \"../data-sync/types\";\n\nexport const createPutListener = (\n  dataSourceUpdates: IDataSourceUpdates,\n  logger?: ILogger,\n  onPutCompleteHandler: VoidFunction = () => {\n  },\n) => ({\n  deserializeData: deserializeAll,\n  processJson: async (userKeyId: string, {flags}: Flags) => {\n    const initData: IStoreDataStorage = {\n      flags: flags,\n      version: 0\n    };\n\n    logger?.debug('Initializing all data');\n    dataSourceUpdates.init(userKeyId, initData, onPutCompleteHandler);\n  },\n});\n\nexport const createPatchListener = (\n  dataSourceUpdates: IDataSourceUpdates,\n  logger?: ILogger,\n  onPatchCompleteHandler: VoidFunction = () => {\n  },\n) => ({\n  deserializeData: deserializePatch,\n  processJson: async (userKeyId: string, data: IPatchData[]) => {\n    if (data?.length === 0) {\n      onPatchCompleteHandler?.();\n      return;\n    }\n\n    data?.forEach(item => {\n      logger?.debug(`Updating ${ item.data.key } in ${ item.kind.namespace }`);\n      dataSourceUpdates.upsert(userKeyId, item.kind, item.data, onPatchCompleteHandler);\n    })\n  },\n});\n\n\nexport const createStreamListeners = (\n  dataSourceUpdates: IDataSourceUpdates,\n  logger?: ILogger,\n  onCompleteHandlers?: {\n    put?: VoidFunction;\n    patch?: VoidFunction;\n    delete?: VoidFunction;\n  },\n) => {\n  const listeners = new Map<EventName, ProcessStreamResponse>();\n  listeners.set('put', createPutListener(dataSourceUpdates, logger, onCompleteHandlers?.put));\n  listeners.set('patch', createPatchListener(dataSourceUpdates, logger, onCompleteHandlers?.patch));\n  return listeners;\n};\n","export * from './createStreamListeners';\nexport * from './DataSourceUpdates';","export enum DataSyncModeEnum {\n  POLLING = 'polling',\n  STREAMING = 'streaming'\n}","import { IDataSynchronizer } from \"./IDataSynchronizer\";\n\nexport class NullDataSynchronizer implements IDataSynchronizer {\n  close(): void {\n  }\n\n  start(): void {\n  }\n\n  stop(): void {\n  }\n\n  identify(): void {\n  }\n}","import { isHttpRecoverable, PollingError } from \"../errors\";\nimport { IDataSynchronizer } from \"./IDataSynchronizer\";\nimport { ILogger } from \"../logging/ILogger\";\nimport Configuration from \"../Configuration\";\nimport { EventName, PollingErrorHandler, ProcessStreamResponse, StreamResponseEventType } from \"./types\";\nimport Requestor from \"./Requestor\";\nimport { httpErrorMessage } from \"../utils/http\";\nimport { IUser } from \"../options/IUser\";\n\nexport default class PollingDataSynchronizer implements IDataSynchronizer {\n  private stopped = false;\n\n  private logger?: ILogger;\n\n  private pollingInterval: number;\n\n  private user: IUser | undefined;\n\n  private timeoutHandle: any;\n\n  constructor(\n    config: Configuration,\n    private readonly requestor: Requestor,\n    private readonly getStoreTimestamp: () => number,\n    private readonly listeners: Map<EventName, ProcessStreamResponse>,\n    private readonly errorHandler?: PollingErrorHandler,\n  ) {\n    this.logger = config.logger;\n    this.pollingInterval = config.pollingInterval;\n    this.user = config.user;\n  }\n\n  private poll() {\n    if (this.stopped) {\n      return;\n    }\n\n    const startTime = Date.now();\n    this.logger?.debug('Polling for feature flag and segments updates');\n    this.requestor.requestData(this.getStoreTimestamp(), this.user, (err, body) => {\n      const elapsed = Date.now() - startTime;\n      const sleepFor = Math.max(this.pollingInterval - elapsed, 0);\n\n      this.logger?.debug('Elapsed: %d ms, sleeping for %d ms', elapsed, sleepFor);\n      if (err) {\n        const {status} = err;\n        if (status && !isHttpRecoverable(status)) {\n          const message = httpErrorMessage(err, 'polling request');\n          this.logger?.error(message);\n          this.errorHandler?.(new PollingError(message, status));\n          // It is not recoverable, return and do not trigger another\n          // poll.\n          return;\n        }\n        this.logger?.warn(httpErrorMessage(err, 'polling request', 'will retry'));\n      } else {\n        let featureFlags = [];\n        let userKeyId = this.user?.keyId!;\n        let processStreamResponse: ProcessStreamResponse | undefined = this.listeners.get('patch');\n\n        if (body) {\n          const message = JSON.parse(body);\n          if (message.messageType === 'data-sync') {\n            switch (message.data.eventType) {\n              case StreamResponseEventType.patch:\n                processStreamResponse = this.listeners.get('patch');\n                break;\n              case StreamResponseEventType.full:\n                processStreamResponse = this.listeners.get('put');\n                break;\n            }\n\n            ({featureFlags, userKeyId} = message.data);\n          }\n        }\n\n        const data = processStreamResponse?.deserializeData?.(featureFlags);\n        processStreamResponse?.processJson?.(userKeyId, data);\n      }\n\n      // Falling through, there was some type of error and we need to trigger\n      // a new poll.\n      this.timeoutHandle = setTimeout(() => {\n        this.poll();\n      }, sleepFor);\n    });\n  }\n\n  identify(user: IUser) {\n    this.user = {...user};\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n      this.timeoutHandle = undefined;\n    }\n    this.poll();\n  }\n\n  close(): void {\n    this.stop();\n  }\n\n  start(): void {\n    this.poll();\n  }\n\n  stop(): void {\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n      this.timeoutHandle = undefined;\n    }\n    this.stopped = true;\n  }\n}\n\n\n\n","import { IRequestor } from \"./IRequestor\";\nimport Configuration from \"../Configuration\";\nimport { IInfo } from \"../platform/IInfo\";\nimport { IRequestOptions, IRequests, IResponse } from \"../platform/requests\";\nimport { StreamingError } from \"../errors\";\nimport { defaultHeaders } from \"../utils/http\";\n\n/**\n * @internal\n */\nexport default class Requestor implements IRequestor {\n  private readonly headers: Record<string, string>;\n\n  private readonly uri: string;\n\n  constructor(\n    sdkKey: string,\n    config: Configuration,\n    info: IInfo,\n    private readonly requests: IRequests,\n  ) {\n    this.headers = defaultHeaders(sdkKey, info);\n    this.uri = config.pollingUri;\n  }\n\n  /**\n   * Perform a request and utilize the ETag cache. The ETags are cached in the\n   * requestor instance.\n   */\n  private async request(\n    requestUrl: string,\n    options: IRequestOptions,\n  ): Promise<{\n    res: IResponse;\n    body: string;\n  }> {\n    const res = await this.requests.fetch(requestUrl, options);\n\n    const body = await res.text();\n\n    return {res, body};\n  }\n\n  async requestData(timestamp: number, payload: any, cb: (err: any, body: any) => void) {\n    const options: IRequestOptions = {\n      method: 'POST',\n      headers: this.headers,\n      body: JSON.stringify(payload)\n    };\n    try {\n      const {res, body} = await this.request(`${ this.uri }?timestamp=${ timestamp ?? 0 }`, options);\n      if (res.status !== 200 && res.status !== 304) {\n        const err = new StreamingError(`Unexpected status code: ${ res.status }`, res.status);\n        return cb(err, undefined);\n      }\n      return cb(undefined, res.status === 304 ? null : body);\n    } catch (err) {\n      return cb(err, undefined);\n    }\n  }\n}\n","import { IDataSynchronizer } from \"./IDataSynchronizer\";\nimport ClientContext from \"../options/ClientContext\";\nimport { EventName, ProcessStreamResponse } from \"./types\";\nimport { ILogger } from \"../logging/ILogger\";\nimport { IWebSocketWithEvents } from \"../platform/IWebSocket\";\nimport { IUser } from \"../options/IUser\";\n\nclass WebSocketDataSynchronizer implements IDataSynchronizer {\n  private socket?: IWebSocketWithEvents;\n  private readonly logger?: ILogger;\n\n  private connectionAttemptStartTime?: number;\n\n  constructor(\n    sdkKey: string,\n    user: IUser,\n    clientContext: ClientContext,\n    socket: IWebSocketWithEvents,\n    private readonly getStoreTimestamp: () => number,\n    private readonly listeners: Map<EventName, ProcessStreamResponse>,\n    webSocketPingInterval: number\n  ) {\n    const {logger, streamingUri} = clientContext;\n\n    this.logger = logger;\n    this.socket = socket;\n    this.socket.config({\n      sdkKey,\n      streamingUri,\n      pingInterval: webSocketPingInterval,\n      user,\n      logger,\n      getStoreTimestamp\n    });\n\n    this.listeners.forEach(({deserializeData, processJson}, eventName) => {\n      this.socket?.addListener(eventName, (event) => {\n        this.logger?.debug(`Received ${ eventName } event`);\n\n        if (event?.data) {\n          const {featureFlags, userKeyId} = event.data;\n          const data = deserializeData(featureFlags);\n          processJson(userKeyId, data);\n        }\n      });\n    })\n  }\n\n  identify(user: IUser): void {\n    this.socket?.identify(user);\n  }\n\n  start(): void {\n    this.logConnectionStarted();\n\n    this.socket?.connect();\n  }\n\n  private logConnectionStarted() {\n    this.connectionAttemptStartTime = Date.now();\n    this.logger?.info(`Stream connection attempt StartTime ${ this.connectionAttemptStartTime }`);\n  }\n\n  close(): void {\n    this.stop();\n  }\n\n  stop(): void {\n    this.socket?.close();\n    this.socket = undefined;\n  }\n}\n\nexport default WebSocketDataSynchronizer;","export * from './DataSyncMode';\nexport * from './IDataSynchronizer';\nexport * from './IRequestor';\nexport * from './NullDataSynchronizer';\nexport * from './PollingDataSynchronizer';\nexport * from './Requestor';\nexport * from './types';\nexport * from './utils';\nexport * from './WebSocketDataSynchronizer';","import { PollingError } from \"../errors\";\nimport { IFlag } from \"../evaluation/data/IFlag\";\n\nexport type PollingErrorHandler = (err: PollingError) => void;\n\nexport enum StreamResponseEventType {\n  full = 'full',\n  patch = 'patch'\n}\n\nexport interface IStreamResponse {\n  eventType: StreamResponseEventType,\n  featureFlags: IFlag[]\n}\n\nexport type EventName = 'delete' | 'patch' | 'ping' | 'put';\nexport type ProcessStreamResponse = {\n  deserializeData: (flags: IFlag[]) => any;\n  processJson: (userKeyId: string, json: any) => void;\n};","/********************** encode text begin *****************************/\nconst alphabet: Record<string, string> = {\n  \"0\": \"Q\",\n  \"1\": \"B\",\n  \"2\": \"W\",\n  \"3\": \"S\",\n  \"4\": \"P\",\n  \"5\": \"H\",\n  \"6\": \"D\",\n  \"7\": \"X\",\n  \"8\": \"Z\",\n  \"9\": \"U\",\n}\n\nfunction encodeNumber(param: number, length: number): string {\n  var s = \"000000000000\" + param;\n  const numberWithLeadingZeros = s.slice(s.length - length);\n  return numberWithLeadingZeros.split('').map(n => alphabet[n]).join('');\n}\n\n// generate connection token\nexport function generateConnectionToken(text: string): string {\n  text = text.replace(/=*$/, '');\n  const timestamp = Date.now();\n  const timestampCode = encodeNumber(timestamp, timestamp.toString().length);\n  // get random number less than the length of the text as the start point, and it must be greater or equal to 2\n  const start = Math.max(Math.floor(Math.random() * text.length), 2);\n\n  return `${ encodeNumber(start, 3) }${ encodeNumber(timestampCode.length, 2) }${ text.slice(0, start) }${ timestampCode }${ text.slice(start) }`;\n}\n\n/********************** encode text end *****************************/","export class PollingError extends Error {\n  public readonly status?: number;\n\n  constructor(message: string, status?: number) {\n    super(message);\n    this.status = status;\n    this.name = 'FbPollingError';\n  }\n}\n\nexport class StreamingError extends Error {\n  public readonly code?: number;\n\n  constructor(message: string, code?: number) {\n    super(message);\n    this.code = code;\n    this.name = 'FbStreamingError';\n  }\n}\n\nexport class UnexpectedResponseError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'FbUnexpectedResponseError';\n  }\n}\n\n\nexport class ClientError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'FbClientError';\n  }\n}\n\nexport class TimeoutError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'FeatBitTimeoutError';\n  }\n}\n\nexport function isHttpRecoverable(status: number) {\n  if (status >= 400 && status < 500) {\n    return status === 400 || status === 408 || status === 429;\n  }\n  return true;\n}","import { ReasonKinds } from \"./ReasonKinds\";\nimport { IFlag } from \"./data/IFlag\";\nimport { EvalEvent } from \"../events/event\";\nimport { IUser } from \"../options/IUser\";\n\n/**\n * A class which encapsulates the result of an evaluation. It allows for differentiating between\n * successful and error result types.\n *\n * @internal\n */\nexport default class EvalResult {\n  protected constructor(\n    public kind: ReasonKinds,\n    public value: IFlag | null,\n    public reason?: string,\n  ) {\n  }\n\n  static flagNotFound(flagKey: string) {\n    return new EvalResult(ReasonKinds.FlagNotFound, null, `flag not found: ${ flagKey }`);\n  }\n\n  static matched(val: IFlag) {\n    return new EvalResult(ReasonKinds.Match, val, 'target match');\n  }\n\n  toEvalEvent(user: IUser): EvalEvent | null {\n    if (this.kind !== ReasonKinds.Match) {\n      return null;\n    }\n\n    const targetedVariation = this.value?.variations.find(v => v.value === this.value?.variation);\n    return new EvalEvent(user, this.value?.id!, targetedVariation!, this.value?.sendToExperiment!);\n  }\n}","import { IFlag } from \"./data/IFlag\";\nimport EvalResult from \"./EvalResult\";\nimport { IStore } from \"../platform/IStore\";\nimport DataKinds from \"../store/DataKinds\";\n\n/**\n * @internal\n */\nexport default class Evaluator {\n  constructor(private store: IStore) {\n  }\n\n  /**\n   * Evaluate the given flag against the given context.\n   * @param flagKey The key of the feature flag.\n   */\n  evaluate(\n    flagKey: string,\n  ): EvalResult {\n    const flag = this.store.get(DataKinds.Flags, flagKey) as unknown as IFlag;\n    if (!flag) {\n      return EvalResult.flagNotFound(flagKey);\n    }\n\n    return EvalResult.matched(flag);\n  }\n}","/**\n * Different kinds of error which may be encountered during evaluation.\n */\nexport enum ReasonKinds {\n  ClientNotReady = 'ClientNotReady',\n  Match = 'Match',\n  WrongType = 'WrongType',\n  FlagNotFound = 'FlagNotFound',\n  Error = 'Error'\n}","export type FlagValue = any;\n\nexport enum VariationDataType {\n  string = 'string',\n  boolean = 'boolean',\n  number = 'number',\n  json = 'json',\n  empty = ''\n}\n\nexport interface IVariation {\n  id: number,\n  value: FlagValue\n}\n\nexport interface IFlagBase {\n  id: string, // the key\n  variation: FlagValue,\n  variationType: VariationDataType,\n  sendToExperiment?: boolean,\n  timestamp?: number,\n  variationOptions?: IVariation[],\n}\n\nexport interface IFlag extends IFlagBase {\n  key: string, // the same value to id\n  variations: IVariation[],// the same value to variationOptions\n  version: number\n}\n","export * from './IFlag';","export * from './data';\nexport * from './EvalResult';\nexport * from './Evaluator';\nexport * from './IEvalDetail';\nexport * from './ReasonKinds';","import { IEventProcessor } from \"./IEventProcessor\";\nimport { EventDispatcher } from \"./EventDispatcher\";\nimport ClientContext from \"../options/ClientContext\";\nimport { FlushEvent, IEvent, ShutdownEvent } from \"./event\";\nimport { isNullOrUndefined } from \"../utils/isNullOrUndefined\";\nimport { IEventQueue } from \"./IEventQueue\";\nimport { DefaultEventQueue } from \"./DefaultEventQueue\";\nimport { ILogger } from \"../logging/ILogger\";\n\nexport class DefaultEventProcessor implements IEventProcessor {\n  private readonly logger: ILogger;\n  private readonly flushInterval: number;\n  private readonly eventDispatcher: EventDispatcher;\n  private readonly eventQueue: IEventQueue;\n  private closed: boolean = false;\n\n  constructor(clientContext: ClientContext) {\n    const {logger, flushInterval, maxEventsInQueue} = clientContext;\n    this.logger = logger!;\n    this.flushInterval = flushInterval;\n    this.eventQueue = new DefaultEventQueue(maxEventsInQueue, this.logger);\n    this.eventDispatcher = new EventDispatcher(clientContext, this.eventQueue);\n\n    this.flushLoop();\n  }\n\n  private flushLoop() {\n    if (this.closed) {\n      return;\n    }\n\n    setTimeout(async () => {\n      try {\n        await this.flush();\n      } catch (err) {\n        this.logger.error('Unexpected error while flushing events in event processor.', err);\n      }\n\n      this.flushLoop();\n    }, this.flushInterval);\n  }\n\n  flush(): Promise<any> {\n    const flushEvent = new FlushEvent();\n    this.record(flushEvent);\n    return flushEvent.waitForCompletion();\n  }\n\n  async close(): Promise<void> {\n    if (this.closed) {\n      return;\n    }\n\n    // send a shutdown event to dispatcher\n    const shutdown = new ShutdownEvent();\n    this.record(shutdown);\n\n    try {\n      await shutdown.waitForCompletion();\n    } catch (err) {\n      this.logger.error('Event processor shutdown but not complete.');\n    }\n\n    // mark the event queue as complete for adding\n    this.eventQueue.close();\n    this.closed = true;\n  }\n\n  record(event: IEvent | null): boolean {\n    if (isNullOrUndefined(event)) {\n      return false;\n    }\n\n    if (!this.eventQueue.addEvent(event!)) {\n      if (event instanceof FlushEvent) {\n        event.complete();\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n}","import { IEventQueue } from \"./IEventQueue\";\nimport { IEvent } from \"./event\";\nimport { ILogger } from \"../logging/ILogger\";\n\nexport class DefaultEventQueue implements IEventQueue {\n  private events: IEvent[];\n  private closed: boolean = false;\n\n  constructor(private readonly capacity: number, private readonly logger: ILogger) {\n    this.events = [];\n  }\n\n  addEvent(event: IEvent): boolean {\n    if (this.closed) {\n      return false;\n    }\n\n    if (this.events.length >= this.capacity) {\n      this.logger.warn(\"Events are being produced faster than they can be processed. We shouldn't see this.\");\n      return false;\n    }\n\n    this.events.push(event);\n    return true;\n  }\n\n  clear(): void {\n    this.events = [];\n  }\n\n  shift(): IEvent | undefined {\n    return this.events.shift();\n  }\n\n  close(): void {\n    this.closed = true;\n  }\n\n  get eventsSnapshot(): IEvent[] {\n    return [...this.events];\n  }\n\n  get length(): number {\n    return this.events.length;\n  }\n\n  get isEmpty(): boolean {\n    return this.length === 0;\n  }\n}","import { DeliveryStatus, IEventSender, IEventSenderResult } from \"./IEventSender\";\nimport ClientContext from \"../options/ClientContext\";\nimport { defaultHeaders, httpErrorMessage } from \"../utils/http\";\nimport { IRequests } from \"../platform/requests\";\nimport { isHttpRecoverable, UnexpectedResponseError } from \"../errors\";\nimport sleep from \"../utils/sleep\";\n\nexport class DefaultEventSender implements IEventSender {\n  private readonly defaultHeaders: {\n    [key: string]: string;\n  };\n  private readonly eventsUri: string;\n  private requests: IRequests;\n\n  constructor(clientContext: ClientContext) {\n    const {\n      sdkKey,\n      eventsUri,\n      platform\n    } = clientContext;\n\n    const {info, requests} = platform;\n    this.defaultHeaders = defaultHeaders(sdkKey, info);\n    this.eventsUri = eventsUri;\n    this.requests = requests;\n  }\n\n  async send(payload: string, retry: boolean): Promise<IEventSenderResult> {\n    const res: IEventSenderResult = {\n      status: DeliveryStatus.Succeeded,\n    };\n\n    const headers: Record<string, string> = {\n      ...this.defaultHeaders,\n    }\n\n    let error;\n    try {\n      const {status} = await this.requests.fetch(this.eventsUri, {\n        headers,\n        body: payload,\n        method: 'POST',\n      });\n\n      if (status >= 200 && status <= 299) {\n        return res;\n      }\n\n      error = new UnexpectedResponseError(\n        httpErrorMessage({status, message: 'some events were dropped'}, 'event posting'),\n      );\n\n      if (!isHttpRecoverable(status)) {\n        res.status = DeliveryStatus.FailedAndMustShutDown;\n        res.error = error;\n        return res;\n      }\n    } catch (err) {\n      error = err;\n    }\n\n    // recoverable but not retrying\n    if (error && !retry) {\n      res.status = DeliveryStatus.Failed;\n      res.error = error;\n      return res;\n    }\n\n    // wait 1 second before retrying\n    await sleep();\n\n    return this.send(payload, false);\n  }\n}","import { IEventSerializer } from \"./EventSerializer\";\nimport { EvalEvent, IEvent, MetricEvent } from \"./event\";\n\nexport class DefaultEventSerializer implements IEventSerializer {\n  serialize(events: IEvent[]): string {\n    const payload = events\n      .map(event => event instanceof EvalEvent || event instanceof MetricEvent ? event.toPayload() : null)\n      .filter(event => event !== null);\n\n    return JSON.stringify(payload);\n  }\n}","import { ILogger } from \"../logging/ILogger\";\nimport ClientContext from \"../options/ClientContext\";\nimport { DeliveryStatus, IEventSender } from \"./IEventSender\";\nimport { IEventQueue } from \"./IEventQueue\";\nimport { DefaultEventQueue } from \"./DefaultEventQueue\";\nimport { DefaultEventSender } from \"./DefaultEventSender\";\nimport { AsyncEvent, FlushEvent, IEvent, PayloadEvent, ShutdownEvent } from \"./event\";\nimport { IEventSerializer } from \"./EventSerializer\";\nimport { DefaultEventSerializer } from \"./DefaultEventSerializer\";\nimport sleep from \"../utils/sleep\";\n\nexport class EventDispatcher {\n  private readonly logger: ILogger;\n  private sender: IEventSender;\n  private buffer: IEventQueue;\n  private serializer: IEventSerializer;\n\n  private maxEventPerRequest = 50;\n  private stopped: boolean = false;\n\n  constructor(clientContext: ClientContext, queue: IEventQueue) {\n    const {logger, maxEventsInQueue} = clientContext;\n    this.logger = logger!;\n\n    this.buffer = new DefaultEventQueue(maxEventsInQueue, this.logger);\n    this.sender = new DefaultEventSender(clientContext);\n    this.serializer = new DefaultEventSerializer();\n\n    this.dispatchLoop(queue).then();\n  }\n\n  private async dispatchLoop(queue: IEventQueue) {\n    this.logger.debug('Start dispatch loop.');\n\n    let running = true;\n    while (running) {\n      try {\n        const event = queue.shift();\n\n        if (event === undefined) {\n          await sleep(1000);\n          continue;\n        }\n\n        if (event instanceof PayloadEvent) {\n          this.addEventToBuffer(event);\n        } else if (event instanceof FlushEvent) {\n          await this.triggerFlush(event);\n        } else if (event instanceof ShutdownEvent) {\n          await this.triggerFlush(event);\n          this.stopped = true;\n          running = false;\n        }\n      } catch (err) {\n        this.logger.error('Unexpected error in event dispatcher.', err);\n      }\n    }\n\n    this.logger.debug('Finish dispatch loop.');\n  }\n\n  private addEventToBuffer(event: IEvent) {\n    if (this.stopped) {\n      return;\n    }\n\n    if (this.buffer.addEvent(event)) {\n      this.logger.debug('Added event to buffer.');\n    } else {\n      this.logger.warn('Exceeded event queue capacity, event will be dropped. Increase capacity to avoid dropping events.');\n    }\n  }\n\n  private async triggerFlush(event: AsyncEvent) {\n    if (this.stopped) {\n      event.complete();\n      return;\n    }\n\n    if (this.buffer.isEmpty) {\n      event.complete();\n      this.logger.debug('Flush empty buffer.');\n      // There are no events to flush. If we don't complete the message, then the async task may never\n      // complete (if it had a non-zero positive timeout, then it would complete after the timeout).\n      return;\n    }\n\n    const snapshot = this.buffer.eventsSnapshot;\n    this.buffer.clear();\n    try {\n      await this.flushEvents(snapshot);\n      this.logger.debug(`${ snapshot.length } events has been flushed.`);\n    } catch (err) {\n      this.logger.warn('Exception happened when flushing events', err);\n    }\n\n    event.complete();\n  }\n\n  private async flushEvents(events: IEvent[]) {\n    events = this.getUniqueEvents(events);\n    const total = events.length;\n    for (let i = 0; i < total; i += this.maxEventPerRequest) {\n      const length = Math.min(this.maxEventPerRequest, total - i);\n      const slice = events.slice(i, i + length);\n      const payload = this.serializer.serialize(slice);\n\n      const {status} = await this.sender.send(payload, true);\n      if (status === DeliveryStatus.FailedAndMustShutDown) {\n        this.stopped = true;\n      }\n    }\n  }\n\n  private getUniqueEvents(events: IEvent[]): IEvent[] {\n    const uniqueEvents: IEvent[] = [];\n    const hashes: string[] = [];\n\n    for (const event of events) {\n      if (!hashes.includes(event.hash)) {\n        uniqueEvents.push(event);\n        hashes.push(event.hash);\n      }\n    }\n\n    return uniqueEvents;\n  }\n}","export enum DeliveryStatus {\n  Succeeded,\n  Failed,\n  FailedAndMustShutDown\n}\n\nexport interface IEventSenderResult {\n  status: DeliveryStatus,\n  error?: any\n}\n\nexport interface IEventSender {\n  send(payload: string, retry: boolean): Promise<IEventSenderResult>;\n}","import { IEventProcessor } from \"./IEventProcessor\";\nimport { IEvent } from \"./event\";\n\nexport class NullEventProcessor implements IEventProcessor {\n  flush(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  record(event: IEvent | null): boolean {\n    return false;\n  }\n}","import { IUser } from \"../options/IUser\";\nimport { IVariation } from \"../evaluation/data/IFlag\";\n\nexport interface IEvent {\n  hash: string;\n}\n\nexport class AsyncEvent implements IEvent {\n  private readonly isCompletedPromise?: Promise<AsyncEvent>;\n  private resolveFn?: (value: AsyncEvent) => void;\n  timestamp = (new Date()).getTime();\n\n  get hash(): string {\n    return this.timestamp.toString();\n  }\n\n  constructor() {\n    this.isCompletedPromise = new Promise<AsyncEvent>((resolve) => {\n      this.resolveFn = resolve;\n    });\n  }\n\n  waitForCompletion(): Promise<AsyncEvent> {\n    return this.isCompletedPromise!;\n  }\n\n  complete() {\n    this.resolveFn?.(this);\n  }\n}\n\nexport class FlushEvent extends AsyncEvent {\n}\n\nexport class ShutdownEvent extends AsyncEvent {\n}\n\nexport class PayloadEvent implements IEvent {\n  timestamp = (new Date()).getTime();\n\n  get hash(): string {\n    return this.timestamp.toString();\n  }\n\n  toPayload(): any {\n  };\n}\n\nexport class MetricEvent extends PayloadEvent {\n  constructor(\n    public user: IUser,\n    public eventName: string,\n    public appType: string,\n    public metricValue: number\n  ) {\n    super();\n  }\n\n  private userPayload() {\n    return {\n      keyId: this.user.keyId,\n      name: this.user.name,\n      customizedProperties: this.user.customizedProperties\n    }\n  }\n\n  toPayload(): any {\n    return {\n      user: this.userPayload(),\n      metrics: [{\n        route: 'index/metric',\n        timestamp: this.timestamp,\n        numericValue: this.metricValue,\n        appType: this.appType,\n        eventName: this.eventName,\n        type: 'CustomEvent'\n      }]\n    }\n  }\n\n  get hash(): string {\n    const payload = this.toPayload();\n    const hasObject = {\n      user: payload.user,\n      metrics: payload.metrics.map((m: any) => ({...m, timestamp: undefined}))\n    }\n    return JSON.stringify(hasObject);\n  }\n}\n\nexport class EvalEvent extends PayloadEvent {\n  constructor(\n    public user: IUser,\n    public flagKey: string,\n    public variation: IVariation,\n    public sendToExperiment: boolean\n  ) {\n    super();\n  }\n\n  private userPayload() {\n    return {\n      keyId: this.user.keyId,\n      name: this.user.name,\n      customizedProperties: this.user.customizedProperties\n    }\n  }\n\n  toPayload(): any {\n    return {\n      user: this.userPayload(),\n      variations: [{\n        featureFlagKey: this.flagKey,\n        sendToExperiment: this.sendToExperiment,\n        timestamp: this.timestamp,\n        variation: this.variation\n      }]\n    }\n  }\n\n  get hash(): string {\n    const payload = this.toPayload();\n    const hasObject = {\n      user: payload.user,\n      variations: payload.variations.map((m: any) => ({...m, timestamp: undefined}))\n    }\n\n    return JSON.stringify(hasObject);\n  }\n}","export * from './DefaultEventProcessor';\nexport * from './DefaultEventQueue';\nexport * from './DefaultEventSender';\nexport * from './DefaultEventSerializer';\nexport * from './event';\nexport * from './EventDispatcher';\nexport * from './EventSerializer';\nexport * from './IEventProcessor';\nexport * from './IEventQueue';\nexport * from './IEventSender';\nexport * from './NullEventProcessor';\n","export * from './bootstrap';\nexport * from './data-sources';\nexport * from './evaluation';\nexport * from './events';\nexport * from './logging';\nexport * from './options';\nexport * from './platform';\nexport * from './store';\nexport * from './data-sync';\nexport * from './utils';\n\nexport * from './Configuration';\nexport * from './constants';\nexport * from './Context';\nexport * from './errors';\nexport * from './FbClientBuilder';\nexport * from './IContextProperty';\nexport * from './IDataKind';\nexport * from './IFbClient';\nexport * from './IVersionedData';\nexport * from './FbClientCore';\n","import format from './format';\nimport { ILogger } from \"./ILogger\";\nimport { IBasicLoggerOptions } from \"./IBasicLoggerOptions\";\n\nconst LogPriority = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n  none: 4,\n};\n\nconst LevelNames = ['debug', 'info', 'warn', 'error', 'none'];\n\n/**\n * A basic logger which handles filtering by level.\n *\n * With the default options it will write to `console.error`\n * and it will use the formatting provided by `console.error`.\n * If the destination is overwritten, then it will use an included\n * formatter similar to `util.format`.\n *\n * If a formatter is available, then that should be overridden\n * as well for performance.\n */\nexport class BasicLogger implements ILogger {\n  private logLevel: number;\n\n  private name: string;\n\n  private destination?: (line: string) => void;\n\n  private formatter?: (...args: any[]) => string;\n\n  /**\n   * This should only be used as a default fallback and not as a convenient\n   * solution. In most cases you should construct a new instance with the\n   * appropriate options for your specific needs.\n   */\n  static get() {\n    return new BasicLogger({});\n  }\n\n  constructor(options: IBasicLoggerOptions) {\n    this.logLevel = LogPriority[options.level ?? 'info'] ?? LogPriority.info;\n    this.name = options.name ?? 'FeatBit';\n    // eslint-disable-next-line no-console\n    this.destination = options.destination;\n    this.formatter = options.formatter;\n  }\n\n  private tryFormat(...args: any[]): string {\n    try {\n      if (this.formatter) {\n        // In case the provided formatter fails.\n        return this.formatter?.(...args);\n      }\n      return format(...args);\n    } catch {\n      return format(...args);\n    }\n  }\n\n  private tryWrite(msg: string) {\n    try {\n      this.destination!(msg);\n    } catch {\n      // eslint-disable-next-line no-console\n      console.error(msg);\n    }\n  }\n\n  private log(level: number, args: any[]) {\n    if (level >= this.logLevel) {\n      const prefix = `${ LevelNames[level] }: [${ this.name }]`;\n      try {\n        if (this.destination) {\n          this.tryWrite(`${ prefix } ${ this.tryFormat(...args) }`);\n        } else {\n          // `console.error` has its own formatter.\n          // So we don't need to do anything.\n          // eslint-disable-next-line no-console\n          console.error(...args);\n        }\n      } catch {\n        // If all else fails do not break.\n        // eslint-disable-next-line no-console\n        console.error(...args);\n      }\n    }\n  }\n\n  error(...args: any[]): void {\n    this.log(LogPriority.error, args);\n  }\n\n  warn(...args: any[]): void {\n    this.log(LogPriority.warn, args);\n  }\n\n  info(...args: any[]): void {\n    this.log(LogPriority.info, args);\n  }\n\n  debug(...args: any[]): void {\n    this.log(LogPriority.debug, args);\n  }\n}\n","import { ILogger } from \"./ILogger\";\nimport { TypeValidators } from \"../options/Validators\";\n\nconst loggerRequirements = {\n  error: TypeValidators.Function,\n  warn: TypeValidators.Function,\n  info: TypeValidators.Function,\n  debug: TypeValidators.Function,\n};\n\n/**\n * The safeLogger logic exists because we allow the application to pass in a custom logger, but\n * there is no guarantee that the logger works correctly and if it ever throws exceptions there\n * could be serious consequences (e.g. an uncaught exception within an error event handler, due\n * to the SDK trying to log the error, can terminate the application). An exception could result\n * from faulty logic in the logger implementation, or it could be that this is not a logger at\n * all but some other kind of object; the former is handled by a catch block that logs an error\n * message to the SDK's default logger, and we can at least partly guard against the latter by\n * checking for the presence of required methods at configuration time.\n */\nexport class SafeLogger implements ILogger {\n  private logger: ILogger;\n\n  private fallback: ILogger;\n\n  /**\n   * Construct a safe logger with the specified logger.\n   * @param logger The logger to use.\n   * @param fallback A fallback logger to use in case an issue is  encountered using\n   * the provided logger.\n   */\n  constructor(logger: ILogger, fallback: ILogger) {\n    Object.entries(loggerRequirements).forEach(([level, validator]) => {\n      if (!validator.is((logger as any)[level])) {\n        throw new Error(`Provided logger instance must support logger.${ level }(...) method`);\n        // Note that the SDK normally does not throw exceptions to the application, but that rule\n        // does not apply to FbClientNode.init() which will throw an exception if the parameters are so\n        // invalid that we cannot proceed with creating the client. An invalid logger meets those\n        // criteria since the SDK calls the logger during nearly all of its operations.\n      }\n    });\n    this.logger = logger;\n    this.fallback = fallback;\n  }\n\n  private log(level: 'error' | 'warn' | 'info' | 'debug', args: any[]) {\n    try {\n      this.logger[level](...args);\n    } catch {\n      // If all else fails do not break.\n      this.fallback[level](...args);\n    }\n  }\n\n  error(...args: any[]): void {\n    this.log('error', args);\n  }\n\n  warn(...args: any[]): void {\n    this.log('warn', args);\n  }\n\n  info(...args: any[]): void {\n    this.log('info', args);\n  }\n\n  debug(...args: any[]): void {\n    this.log('debug', args);\n  }\n}","import { TypeValidators } from \"../options/Validators\";\n\n\n/**\n * Attempt to produce a string representation of a value.\n * The format should be roughly comparable to `util.format`\n * aside from object which will be JSON versus the `util.inspect`\n * format.\n * @param val\n * @returns A string representation of the value if possible.\n */\nfunction tryStringify(val: any) {\n  if (typeof val === 'string') {\n    return val;\n  }\n  if (val === undefined) {\n    return 'undefined';\n  }\n  if (val === null) {\n    return 'null';\n  }\n  if (Object.prototype.hasOwnProperty.call(val, 'toString')) {\n    try {\n      return val.toString();\n    } catch {\n      /* Keep going */\n    }\n  }\n\n  if (typeof val === 'bigint') {\n    return `${ val }n`;\n  }\n  try {\n    return JSON.stringify(val);\n  } catch (error) {\n    if (error instanceof TypeError && error.message.indexOf('circular') >= 0) {\n      return '[Circular]';\n    }\n    return '[Not Stringifiable]';\n  }\n}\n\n/**\n * Attempt to produce a numeric representation.\n * BigInts have an `n` suffix.\n * @param val\n * @returns The numeric representation or 'NaN' if not numeric.\n */\nfunction toNumber(val: any): string {\n  // Symbol has to be treated special because it will\n  // throw an exception if an attempt is made to convert it.\n  if (typeof val === 'symbol') {\n    return 'NaN';\n  }\n  if (typeof val === 'bigint') {\n    return `${ val }n`;\n  }\n  return String(Number(val));\n}\n\n/**\n * Attempt to produce an integer representation.\n * BigInts have an `n` suffix.\n * @param val\n * @returns The integer representation or 'NaN' if not numeric.\n */\nfunction toInt(val: any): string {\n  if (typeof val === 'symbol') {\n    return 'NaN';\n  }\n  if (typeof val === 'bigint') {\n    return `${ val }n`;\n  }\n  return String(parseInt(val, 10));\n}\n\n/**\n * Attempt to produce a float representation.\n * BigInts have an `n` suffix.\n * @param val\n * @returns The integer representation or 'NaN' if not numeric.\n */\nfunction toFloat(val: any): string {\n  if (typeof val === 'symbol') {\n    return 'NaN';\n  }\n  return String(parseFloat(val));\n}\n\n// Based on:\n// https://nodejs.org/api/util.html#utilformatformat-args\n// The result will not match browser exactly, but it should get the\n// right information through.\nconst escapes: Record<string, (val: any) => string> = {\n  s: (val: any) => tryStringify(val),\n  d: (val: any) => toNumber(val),\n  i: (val: any) => toInt(val),\n  f: (val: any) => toFloat(val),\n  j: (val: any) => tryStringify(val),\n  o: (val: any) => tryStringify(val),\n  O: (val: any) => tryStringify(val),\n  c: () => '',\n};\n\n/**\n * A basic formatted for use where `util.format` is not available.\n * This will not be as performant, but it will produce formatted\n * messages.\n *\n * @internal\n *\n * @param args\n * @returns Formatted string.\n */\nexport default function format(...args: any[]): string {\n  const formatString = args.shift();\n  if (TypeValidators.String.is(formatString)) {\n    let out = '';\n    let i = 0;\n    while (i < formatString.length) {\n      const char = formatString.charAt(i);\n      if (char === '%') {\n        const nextIndex = i + 1;\n        if (nextIndex < formatString.length) {\n          const nextChar = formatString.charAt(i + 1);\n          if (nextChar in escapes && args.length) {\n            const value = args.shift();\n            // This rule is for math.\n            // eslint-disable-next-line no-unsafe-optional-chaining\n            out += escapes[nextChar]?.(value);\n          } else if (nextChar === '%') {\n            out += '%';\n          } else {\n            out += `%${ nextChar }`;\n          }\n          i += 2;\n        }\n      } else {\n        out += char;\n        i += 1;\n      }\n    }\n    // If there are any args left after we exhaust the format string\n    // then just stick those on the end.\n    if (args.length) {\n      if (out.length) {\n        out += ' ';\n      }\n      out += args.map(tryStringify).join(' ');\n    }\n    return out;\n  }\n  return args.map(tryStringify).join(' ');\n}\n","export * from './BasicLogger';\nexport * from './format';\nexport * from './IBasicLoggerOptions';\nexport * from './ILogger';\nexport * from './LogLevel';\nexport * from './SafeLogger';","import { ILogger } from \"../logging/ILogger\";\nimport { IPlatform } from \"../platform/IPlatform\";\nimport { IClientContext } from \"./IClientContext\";\nimport { IUser } from \"./IUser\";\n\n/**\n * The client context provides basic configuration and platform support which are required\n * when building SDK components.\n */\nexport default class ClientContext implements IClientContext {\n  flushInterval: number;\n  maxEventsInQueue: number;\n  offline: boolean;\n  logger: ILogger;\n  eventsUri: string;\n  pollingUri: string;\n  streamingUri: string;\n\n  constructor(\n    public readonly sdkKey: string,\n    configuration: {\n      logger?: ILogger;\n      offline?: boolean;\n      flushInterval: number;\n      maxEventsInQueue: number;\n      streamingUri: string;\n      pollingUri: string;\n      eventsUri: string;\n    },\n    public readonly platform: IPlatform,\n  ) {\n    this.logger = configuration.logger!;\n    this.offline = configuration.offline!;\n    this.flushInterval = configuration.flushInterval;\n    this.maxEventsInQueue = configuration.maxEventsInQueue;\n    this.streamingUri = configuration.streamingUri;\n    this.pollingUri = configuration.pollingUri;\n    this.eventsUri = configuration.eventsUri;\n  }\n}","/**\n * Messages for issues which can be encountered from processing the configuration options.\n */\nexport default class OptionMessages {\n  static optionBelowMinimum(name: string, value: number, min: number): string {\n    return `Config option \"${ name }\" had invalid value of ${ value }, using minimum of ${ min } instead`;\n  }\n\n  static unknownOption(name: string): string {\n    return `Ignoring unknown config option \"${ name }\"`;\n  }\n\n  static wrongOptionType(name: string, expectedType: string, actualType: string): string {\n    return `Config option \"${ name }\" should be of type ${ expectedType }, got ${ actualType }, using default value`;\n  }\n\n  static wrongOptionTypeBoolean(name: string, actualType: string): string {\n    return `Config option \"${ name }\" should be a boolean, got ${ actualType }, converting to boolean`;\n  }\n\n  static partialEndpoint(name: string): string {\n    return `You have set custom uris without specifying the ${ name } URI; connections may not work properly`;\n  }\n\n  static mandatory(name: string): string {\n    return `${ name } is mandatory`;\n  }\n\n  static invalidOptionValue(name: string): string {\n    return `Invalid option value: ${ name }`;\n  }\n\n  static missingKeyInBootstrapValue(key: string): string {\n    return `Missing key \"${ key }\" in bootstrap value`;\n  }\n}","import { IUser } from \"./IUser\";\nimport {IContextProperty} from \"../IContextProperty\";\n\n/**\n * Creates an instance of the FeatBit user.\n *\n * @return\n *   The new {@link IUser} instance.\n */\nexport class UserBuilder {\n  private _keyId: string = '';\n  private _name: string = '';\n  private _custom: IContextProperty[] = [];\n\n  constructor(keyId: string) {\n    this._keyId = keyId;\n  }\n\n  name(name: string): UserBuilder {\n    this._name = name;\n    return this;\n  }\n\n  custom(propertyName: string, value: string): UserBuilder {\n    this._custom?.push({ name: propertyName, value: `${value}` });\n    return this;\n  }\n\n  build(): IUser {\n    return {\n      name: this._name,\n      keyId: this._keyId,\n      customizedProperties: this._custom\n    };\n  }\n}","/* eslint-disable class-methods-use-this */\n/* eslint-disable max-classes-per-file */\n\n// The classes here are static, but needs to be instantiated to\n// support the generic functionality. Which is why we do not care about using\n// `this`\n\n// These validators are also of trivial complexity, so we are allowing more than\n// one per file.\n\nimport OptionMessages from \"./OptionMessages\";\nimport { IFlagBase } from \"../evaluation\";\n\n/**\n * Interface for type validation.\n */\nexport interface TypeValidator {\n  // holding validation error messages\n  messages?: string[];\n\n  is(u: unknown): boolean;\n\n  getType(): string;\n}\n\n/**\n * Validate a factory or instance.\n */\nexport class FactoryOrInstance implements TypeValidator {\n  is(factoryOrInstance: unknown) {\n    if (Array.isArray(factoryOrInstance)) {\n      return false;\n    }\n    const anyFactory = factoryOrInstance as any;\n    const typeOfFactory = typeof anyFactory;\n    return typeOfFactory === 'function' || typeOfFactory === 'object';\n  }\n\n  getType(): string {\n    return 'factory method or object';\n  }\n}\n\n/**\n * Validate a basic type.\n */\nexport class Type<T> implements TypeValidator {\n  private typeName: string;\n\n  protected typeOf: string;\n\n  constructor(typeName: string, example: T) {\n    this.typeName = typeName;\n    this.typeOf = typeof example;\n  }\n\n  is(u: unknown): u is T {\n    if (Array.isArray(u)) {\n      return false;\n    }\n    return typeof u === this.typeOf;\n  }\n\n  getType(): string {\n    return this.typeName;\n  }\n}\n\n/**\n * Validate an array of the specified type.\n *\n * This does not validate instances of types. All class instances\n * of classes will simply objects.\n */\nexport class TypeArray<T> implements TypeValidator {\n  private typeName: string;\n\n  protected typeOf: string;\n\n  constructor(typeName: string, example: T) {\n    this.typeName = typeName;\n    this.typeOf = typeof example;\n  }\n\n  is(u: unknown): u is T {\n    if (Array.isArray(u)) {\n      if (u.length > 0) {\n        return u.every((val) => typeof val === this.typeOf);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  getType(): string {\n    return this.typeName;\n  }\n}\n\n/**\n * Validate a value is a number and is greater or eval than a minimum.\n */\nexport class NumberWithMinimum extends Type<number> {\n  readonly min: number;\n\n  constructor(min: number) {\n    super(`number with minimum value of ${ min }`, 0);\n    this.min = min;\n  }\n\n  override is(u: unknown): u is number {\n    return typeof u === this.typeOf && (u as number) >= this.min;\n  }\n}\n\n/**\n * Validate a value is a string and it matches the given expression.\n */\nexport class StringMatchingRegex extends Type<string> {\n  readonly expression: RegExp;\n\n  constructor(expression: RegExp) {\n    super(`string matching ${ expression }`, '');\n    this.expression = expression;\n  }\n\n  override is(u: unknown): u is string {\n    return !!(u as string).match(this.expression);\n  }\n}\n\n/**\n * Validate a value is a function.\n */\nexport class Function implements TypeValidator {\n  is(u: unknown): u is (...args: any[]) => void {\n    // We cannot inspect the parameters and there isn't really\n    // a generic function type we can instantiate.\n    // So the type guard is here just to make TS comfortable\n    // calling something after using this guard.\n    return typeof u === 'function';\n  }\n\n  getType(): string {\n    return 'function';\n  }\n}\n\nexport class NullableBoolean implements TypeValidator {\n  is(u: unknown): boolean {\n    return typeof u === 'boolean' || typeof u === 'undefined' || u === null;\n  }\n\n  getType(): string {\n    return 'boolean | undefined | null';\n  }\n}\n\nexport class BootstrapValidator implements TypeValidator {\n  messages: string[] = [];\n\n  is(u: unknown): boolean {\n    if (typeof u !== 'object' || u === null) {\n      this.messages.push(OptionMessages.invalidOptionValue('bootstrap'));\n      return false;\n    }\n\n    try {\n      const bootstrap = u as IFlagBase[];\n      for (let flag of bootstrap) {\n        const hasMandatoryKeys = ['id', 'variation'].every((key) => Object.keys(flag).includes(key));\n        const keys = Object.keys(flag);\n\n        if (keys.includes('id')) {\n          this.messages.push(OptionMessages.missingKeyInBootstrapValue('id'));\n        }\n\n        if (keys.includes('variation')) {\n          this.messages.push(OptionMessages.missingKeyInBootstrapValue('variation'));\n        }\n\n        if (this.messages.length > 0) {\n          return false;\n        }\n      }\n    } catch (_) {\n      this.messages.push(OptionMessages.wrongOptionType('bootstrap', this.getType(), typeof u));\n      return false;\n    }\n\n    return true;\n  }\n\n  getType(): string {\n    return 'IFlagBase[]';\n  }\n}\n\nexport class UserValidator implements TypeValidator {\n  messages: string[] = [];\n\n  is(u: unknown): boolean {\n    if (typeof u !== 'object' || u === null) {\n      this.messages.push(OptionMessages.mandatory('user'));\n      return false;\n    }\n\n    const user = u as any;\n\n    if (typeof user.keyId !== 'string' || user.keyId.trim() === '') {\n      this.messages.push(OptionMessages.mandatory('user.keyId'));\n      return false;\n    }\n\n    if (typeof user.name !== 'string' || user.name.trim() === '') {\n      this.messages.push(OptionMessages.mandatory('user.name'));\n      return false;\n    }\n\n    return true;\n  }\n\n  getType(): string {\n    return 'user';\n  }\n}\n\n// Our reference SDK, Go, parses date/time strings with the time.RFC3339Nano format.\n// This regex should match strings that are valid in that format, and no others.\n// Acceptable:\n//   2019-10-31T23:59:59Z, 2019-10-31T23:59:59.100Z,\n//   2019-10-31T23:59:59-07, 2019-10-31T23:59:59-07:00, etc.\n// Unacceptable: no \"T\", no time zone designation\nconst DATE_REGEX = /^\\d\\d\\d\\d-\\d\\d-\\d\\dT\\d\\d:\\d\\d:\\d\\d(\\.\\d\\d*)?(Z|[-+]\\d\\d(:\\d\\d)?)/;\n\n/**\n * Validate a value is a date. Values which are numbers are treated as dates and any string\n * which if compliant with `time.RFC3339Nano` is a date.\n */\nexport class DateValidator implements TypeValidator {\n  is(u: unknown): boolean {\n    return typeof u === 'number' || (typeof u === 'string' && DATE_REGEX.test(u));\n  }\n\n  getType(): string {\n    return 'date';\n  }\n}\n\n/**\n * Validates that a string is a valid kind.\n */\nexport class KindValidator extends StringMatchingRegex {\n  constructor() {\n    super(/^(\\w|\\.|-)+$/);\n  }\n\n  override is(u: unknown): u is string {\n    return super.is(u) && u !== 'kind';\n  }\n}\n\n/**\n * A set of standard type validators.\n */\nexport class TypeValidators {\n  static readonly String = new Type<string>('string', '');\n\n  static readonly Number = new Type<number>('number', 0);\n\n  static readonly ObjectOrFactory = new FactoryOrInstance();\n\n  static readonly Object = new Type<object>('object', {});\n\n  static readonly StringArray = new TypeArray<string>('string[]', '');\n\n  static readonly Boolean = new Type<boolean>('boolean', true);\n\n  static readonly User = new Type<object>('object', {});\n\n  static readonly Bootstrap = new Type<object>('object', {});\n\n  static readonly Function = new Function();\n\n  static createTypeArray<T>(typeName: string, example: T) {\n    return new TypeArray<T>(typeName, example);\n  }\n\n  static numberWithMin(min: number): NumberWithMinimum {\n    return new NumberWithMinimum(min);\n  }\n\n  static stringMatchingRegex(expression: RegExp): StringMatchingRegex {\n    return new StringMatchingRegex(expression);\n  }\n\n  static readonly Date = new DateValidator();\n\n  static readonly Kind = new KindValidator();\n  static readonly NullableBoolean = new NullableBoolean();\n}","export * from './ClientContext';\nexport * from './IClientContext';\nexport * from './IOptions';\nexport * from './IUser';\nexport * from './IValidatedOptions';\nexport * from './OptionMessages';\nexport * from './UserBuilder';\nexport * from './Validators';","import { IInfo, IPlatformData, ISdkData } from \"../IInfo\";\nimport { name, version } from '../../version';\n\n\nexport default class BrowserInfo implements IInfo {\n  get appType(): string {\n    return 'Browser-Client-SDK';\n  }\n\n  platformData(): IPlatformData {\n    return {\n      os: {},\n      name: 'Browser',\n      additional: {},\n    };\n  }\n\n  sdkData(): ISdkData {\n    return {\n      name: name,\n      version: version,\n      userAgent: `${ this.appType }/${ version }`,\n    };\n  }\n}","import { IPlatform } from \"../IPlatform\";\nimport { IInfo } from \"../IInfo\";\nimport { IRequests } from \"../requests\";\nimport { IOptions } from \"../../options/IOptions\";\nimport BrowserInfo from \"./BrowserInfo\";\nimport { BrowserRequests } from \"./BrowserRequests\";\nimport { IWebSocketWithEvents } from \"../IWebSocket\";\nimport BrowserWebSocket from \"./BrowserWebSocket\";\n\nexport class BrowserPlatform implements IPlatform {\n  info: IInfo = new BrowserInfo();\n\n  requests: IRequests;\n  webSocket: IWebSocketWithEvents;\n\n  constructor(options: IOptions) {\n    this.requests = new BrowserRequests();\n    this.webSocket = new BrowserWebSocket();\n  }\n}","import { IRequestOptions, IRequests } from \"../requests\";\n\nexport  class BrowserRequests implements IRequests {\n  fetch(url: string, options: IRequestOptions = {}): Promise<any> {\n    return fetch(url, options);\n  }\n}","import { IWebSocket, IWebSocketConfig } from \"../IWebSocket\";\nimport { Emits } from \"../../utils/Emits\";\nimport { IEventEmitter } from \"../../utils/IEventEmitter\";\nimport { EventEmitter } from \"../../utils/EventEmitter\";\nimport { generateConnectionToken } from \"../../data-sync/utils\";\nimport { StreamResponseEventType } from \"../../data-sync/types\";\nimport { IUser } from \"../../options/IUser\";\n\nconst socketConnectionIntervals = [1000, 3000, 5000, 7000, 11000, 13000, 30000, 60000];\n\nclass BrowserWebSocket implements IWebSocket {\n  emitter: IEventEmitter;\n  private ws?: WebSocket;\n  private retryCounter = 0;\n  private closed: boolean = false;\n\n  private _config: IWebSocketConfig = {} as IWebSocketConfig;\n\n  constructor() {\n    this.emitter = new EventEmitter();\n  }\n\n  identify(user: IUser) {\n    this._config.user = user;\n    this.doDataSync();\n  }\n\n  connect() {\n    let that = this;\n    const startTime = Date.now();\n    const url = this._config.streamingUri.replace(/^http/, 'ws') + `?type=client&token=${ generateConnectionToken(this._config.sdkKey) }`;\n    this.ws = new WebSocket(url);\n\n    // Connection opened\n    that.ws?.addEventListener('open', function (this: WebSocket, event) {\n      // this is the websocket instance to which the current listener is binded to, it's different from that.socket\n      that._config.logger.info(`WebSocket connection succeeded, connection time: ${ Date.now() - startTime } ms`);\n      that.doDataSync();\n      that.sendPingMessage();\n    });\n\n    // Connection closed\n    that.ws?.addEventListener('close', function (event) {\n      that._config.logger.warn('WebSocket closed');\n      if (event.code === 4003) { // do not reconnect when 4003\n        return;\n      }\n\n      that.reconnect();\n    });\n\n    // Connection error\n    that.ws?.addEventListener('error', function (event) {\n      // reconnect\n      that._config.logger.debug('error');\n    });\n\n    // Listen for messages\n    that.ws?.addEventListener('message', function (event) {\n      const message = JSON.parse(event.data as string);\n      if (message.messageType === 'data-sync') {\n        switch (message.data.eventType) {\n          case StreamResponseEventType.patch:\n            that.emitter.emit('patch', message);\n            break;\n          case StreamResponseEventType.full:\n            that.emitter.emit('put', message);\n            break;\n        }\n      }\n    });\n  }\n\n  close() {\n    this.closed = true;\n    this.ws?.close(4003, 'The client is closed by user');\n    this.ws = undefined;\n  }\n\n  config(param: IWebSocketConfig) {\n    if (param.emitter) {\n      this.emitter = param.emitter;\n    }\n\n    this._config = {...param};\n  }\n\n  private sendPingMessage() {\n    const payload = {\n      messageType: 'ping',\n      data: null\n    };\n\n    setTimeout(() => {\n      try {\n        if (this.ws?.readyState === WebSocket.OPEN) {\n          this._config.logger.debug('sending ping')\n          this.ws.send(JSON.stringify(payload));\n          this.sendPingMessage();\n        } else {\n          this._config.logger.debug(`socket closed at ${ new Date() }`);\n        }\n      } catch (err) {\n        this._config.logger.debug(err);\n      }\n    }, this._config.pingInterval);\n  }\n\n  private doDataSync() {\n    const payload = {\n      messageType: 'data-sync',\n      data: {\n        timestamp: this._config.getStoreTimestamp(),\n        user: this._config.user\n      }\n    };\n\n    try {\n      if (this.ws?.readyState === WebSocket.OPEN) {\n        this._config.logger.debug('requesting data');\n        this.ws?.send(JSON.stringify(payload));\n      } else {\n        this._config.logger.error(`not requesting data because socket not open`);\n      }\n    } catch (err) {\n      this._config.logger.debug(err);\n    }\n  }\n\n  private reconnect() {\n    if (!this.closed) {\n      this.ws = undefined;\n      const waitTime = socketConnectionIntervals[Math.min(this.retryCounter++, socketConnectionIntervals.length - 1)];\n      this._config.logger.info(`The client will try to reconnect in ${ waitTime } milliseconds.`);\n      setTimeout(() => {\n        this._config.logger.info(`The client is trying to reconnect, flag evaluation results may be stale until reconnected, waited for: ${ waitTime } milliseconds`);\n        this.connect();\n      }, waitTime);\n    }\n  }\n}\n\nexport default Emits(BrowserWebSocket);","import { FbClientCore } from \"../../FbClientCore\";\nimport { IOptions } from \"../../options/IOptions\";\nimport { BasicLogger } from \"../../logging/BasicLogger\";\nimport { EventEmitter } from \"../../utils/EventEmitter\";\nimport { SafeLogger } from \"../../logging/SafeLogger\";\nimport { Emits } from \"../../utils/Emits\";\nimport { IEventEmitter } from \"../../utils/IEventEmitter\";\nimport { BrowserPlatform } from \"./BrowserPlatform\";\nimport LocalStorageStore from \"./LocalStorageStore\";\nimport { IPlatform } from \"../IPlatform\";\n\n/**\n * @ignore\n */\nclass FbClient extends FbClientCore {\n  emitter: IEventEmitter;\n\n  constructor(options: IOptions, platform: IPlatform | undefined = undefined) {\n    const fallbackLogger = new BasicLogger({\n      level: 'none',\n      destination: console.log\n    });\n\n    const logger = options.logger ? new SafeLogger(options.logger, fallbackLogger) : fallbackLogger;\n\n    const emitter = new EventEmitter(logger);\n\n    let { store } = options;\n    if (!store) {\n      store = new LocalStorageStore(options);\n    }\n\n    super(\n      {...options, logger, store },\n      platform ?? new BrowserPlatform({...options, logger}),\n      {\n        onError: (err: Error) => {\n          if (emitter.listenerCount('error')) {\n            emitter.emit('error', err);\n          }\n        },\n        onFailed: (err: Error) => {\n          emitter.emit('failed', err);\n        },\n        onReady: () => {\n          emitter.emit('ready');\n        },\n        onUpdate: (keys: string[]) => {\n          emitter.emit('update', [keys]);\n          keys.forEach((key) => emitter.emit(`update:${ key }`, key));\n        },\n        hasEventListeners: () =>\n          emitter\n            .eventNames()\n            .some(\n              (name) =>\n                name === 'update' || (typeof name === 'string' && name.startsWith('update:')),\n            ),\n      },\n    );\n\n    this.emitter = emitter;\n  }\n}\n\nexport default Emits(FbClient);","import {\n  StoreStorageKey,\n  IStoreDataStorage, CurrentUserStorageKey\n} from \"../../store/store\";\nimport { IOptions } from \"../../options/IOptions\";\nimport { BaseStore } from \"../../store/BaseStore\";\nimport { ILogger } from \"../../logging\";\nimport { serializeUser } from \"../../utils/serializeUser\";\n\nexport default class LocalStorageStore extends BaseStore {\n  private logger: ILogger;\n\n  constructor(options: IOptions) {\n    super();\n\n    this.logger = options.logger!;\n  }\n\n  /* eslint-disable class-methods-use-this */\n  close(): void {\n    // For the LocalStorage store this is a no-op.\n  }\n\n  get description(): string {\n    return 'local-storage-store'\n  }\n\n  // This method needs to be overridden in the child class\n  protected async saveUser(): Promise<void> {\n    localStorage.setItem(CurrentUserStorageKey, serializeUser(this._user));\n  }\n\n  protected override async dumpStoreToStorage() {\n    const storageKey = `${StoreStorageKey}-${this._user.keyId}`;\n    localStorage.setItem(storageKey, JSON.stringify(this.store));\n  }\n\n  protected override async loadStoreFromStorage() {\n    const storageKey = `${StoreStorageKey}-${this._user.keyId}`;\n    const dataStoreStr = localStorage.getItem(storageKey);\n    let store: IStoreDataStorage | null = null;\n\n    try {\n      if (dataStoreStr && dataStoreStr.trim().length > 0) {\n        store = JSON.parse(dataStoreStr);\n      }\n    } catch (err) {\n      this.logger.error(`error while loading local data store: ${storageKey}`, err);\n    }\n\n    if (!!store) {\n      this.store = store;\n    } else {\n      this.store = {\n        flags: {},\n        version: 0\n      };\n    }\n  }\n}","export * from './IInfo';\nexport * from './IStore';\nexport * from './IPlatform';\nexport * from './IWebSocket';\nexport * from './requests';\nexport * from './browser/BrowserRequests';\n\nimport BrowserWebSocket from './browser/BrowserWebSocket';\n\nexport {\n  BrowserWebSocket\n};","import { IStore } from \"../platform\";\nimport { IKeyedStoreItem, IStoreDataStorage, IStoreItem, IStoreKindData } from \"./store\";\nimport { IUser } from \"../options\";\nimport { IDataKind } from \"../IDataKind\";\n\nexport class BaseStore implements IStore {\n  protected store: IStoreDataStorage  = {} as IStoreDataStorage;\n\n  protected initCalled = false;\n\n  protected _user: IUser = {} as IUser;\n\n  constructor() {\n  }\n\n  async identify(user: IUser) {\n    this._user = {...user};\n\n    await this.saveUser();\n    await this.loadStoreFromStorage();\n  }\n\n  get user(): IUser {\n    return this._user;\n  }\n\n  protected async addItem(kind: IDataKind, key: string, item: IStoreItem) {\n    let items = this.store[kind.namespace];\n    if (!items) {\n      items = {};\n      this.store[kind.namespace] = items;\n    }\n    if (Object.hasOwnProperty.call(items, key)) {\n      const old = items[key];\n      // we use <= here, the reason is that when a segment is changed, the upstream service would push the flag\n      // to client SDK with flag timestamp (version) instead of segment timestamp, so to ensure that the new flag value\n      // is saved, we need to use <=\n      if (!old || old.version <= item.version) {\n        items[key] = item;\n      }\n    } else {\n      items[key] = item;\n    }\n\n    if (item.version > this.store.version) {\n      this.store.version = item.version;\n    }\n\n    await this.dumpStoreToStorage();\n  }\n\n  get(kind: IDataKind, key: string): IStoreItem | null {\n    const items = this.store[kind.namespace];\n    if (items) {\n      if (Object.prototype.hasOwnProperty.call(items, key)) {\n        const item = items[key];\n        if (item) {\n          return item;\n        }\n      }\n    }\n    return null;\n  }\n\n  all(kind: IDataKind): [IStoreKindData, number] {\n    const result: IStoreKindData = {};\n    const items = this.store[kind.namespace] ?? {};\n    Object.entries(items).forEach(([key, item]) => {\n      if (item) {\n        result[key] = <IStoreItem>item;\n      }\n    });\n\n    return [result, this.store.version];\n  }\n\n  async init(allData: IStoreDataStorage) {\n    this.store = allData as IStoreDataStorage;\n\n    Object.keys(allData).map(namespace => {\n      Object.entries(allData[namespace]).forEach(([_, item]) => {\n        const ele = item as IStoreItem;\n        if (ele.version > this.store.version) {\n          this.store.version = ele.version;\n        }\n      })\n    });\n\n    await this.dumpStoreToStorage();\n    this.initCalled = true;\n  }\n\n  async upsert(kind: IDataKind, data: IKeyedStoreItem) {\n    await this.addItem(kind, data.key, data);\n  }\n\n  initialized(): boolean {\n    return this.initCalled;\n  }\n\n  /* eslint-disable class-methods-use-this */\n  close(): void {\n    // For the LocalStorage store this is a no-op.\n  }\n\n  get version(): number {\n    return this.store.version;\n  }\n\n  // This getter needs to be overridden in the child class\n  get description(): string {\n    return '';\n  }\n\n  // This method needs to be overridden in the child class\n  protected async saveUser(): Promise<void> {\n  }\n\n  // This method needs to be overridden in the child class\n  protected async loadStoreFromStorage(): Promise<void> {\n  }\n\n  // This method needs to be overridden in the child class\n  protected async dumpStoreToStorage(): Promise<void> {\n  }\n}","import { IDataKind } from \"../IDataKind\";\n\nexport default class DataKinds {\n  static readonly Flags: IDataKind = {\n    namespace: 'flags'\n  };\n}","import {\n  StoreStorageKey,\n  IStoreDataStorage\n} from \"./store\";\nimport { BaseStore } from \"./BaseStore\";\n\nexport default class InMemoryStore extends BaseStore {\n  private allStores: { [DataStoreStorageKey: string]: IStoreDataStorage } = {};\n\n  constructor() {\n    super();\n  }\n\n  /* eslint-disable class-methods-use-this */\n  close(): void {\n    // For the LocalStorage store this is a no-op.\n  }\n\n  get description(): string {\n    return 'in-memory-store'\n  }\n\n  protected async saveUser(): Promise<void> {\n    // For in-memory store, this is a no-op.\n  }\n\n  protected override async dumpStoreToStorage() {\n    const storageKey = `${StoreStorageKey}-${this._user.keyId}`;\n    this.allStores[storageKey] = {...this.store};\n  }\n\n  protected override async loadStoreFromStorage() {\n    const storageKey = `${StoreStorageKey}-${this._user.keyId}`;\n\n    this.store = this.allStores[storageKey] ?? { flags: {}, version: 0 };\n  }\n}","export * from './DataKinds';\nexport * from './IDataSourceUpdates';\nexport * from './InMemoryStore';\nexport * from './serialization';\nexport * from './store';\nexport * from './BaseStore';","import { IFlag } from \"../evaluation/data/IFlag\";\nimport DataKinds from \"./DataKinds\";\nimport { IVersionedData } from \"../IVersionedData\";\nimport { IDataKind } from \"../IDataKind\";\n\nexport interface Flags {\n  flags: { [name: string]: IFlag };\n}\n\ntype VersionedFlag = IVersionedData & IFlag;\n\nexport interface IPatchData {\n  data: VersionedFlag;\n  kind: IDataKind;\n}\n\n/**\n * @internal\n */\nexport function deserializeAll(flags: IFlag[]): Flags {\n  const result = {\n    [DataKinds.Flags.namespace]: {}\n  };\n\n  if (flags?.length) {\n    result[DataKinds.Flags.namespace] = flags.reduce((acc: any, cur: any) => {\n      acc[cur.id] = {...cur, version: cur.timestamp || 0, key: cur.id, variations: cur.variationOptions};\n      return acc;\n    }, {});\n  }\n\n  return result as any as Flags;\n}\n\n/**\n * @internal\n */\nexport function deserializePatch(flags: IFlag[]): IPatchData[] {\n  const result = [\n    ...flags?.map(item => ({\n      data: {\n        ...item,\n        version:item.timestamp,\n        key: item.id,\n        variations: item.variationOptions\n      },\n      kind: DataKinds.Flags\n    })) || []\n  ];\n\n  return result as any as IPatchData[];\n}\n","export const StoreStorageKey = 'fb-datastore';\n\nexport const CurrentUserStorageKey = 'fb-user';\n\n/**\n * Represents an item which can be stored in the feature store.\n */\nexport interface IStoreItem {\n  version: number;\n\n  // The actual data associated with the item.\n  [attribute: string]: any;\n}\n\n/**\n * When upserting an item it must contain a key.\n */\nexport interface IKeyedStoreItem extends IStoreItem {\n  key: string;\n}\n\n/**\n * Represents the storage for a single kind of data. e.g. 'flag' or 'segment'.\n */\nexport interface IStoreKindData {\n  [key: string]: IStoreItem;\n}\n\n/**\n * Represents the storage for the full data store.\n */\nexport interface IStoreDataStorage {\n  flags: IStoreKindData;\n  version: number;\n\n  // This attribute is to ingore the type check error\n  [attribute: string]: any;\n}","import { IEventEmitter } from \"./IEventEmitter\";\n\nexport type EventableConstructor<T = {}> = new (...args: any[]) => T;\nexport type Eventable = EventableConstructor<{ emitter: IEventEmitter }>;\n\n/**\n * Adds the implementation of an event emitter to something that contains\n * a field of `emitter` with type `EventEmitter`.\n * @param Base The class to derive the mixin from.\n * @returns A class extending the base with an event emitter.\n */\nexport function Emits<TBase extends Eventable>(Base: TBase) {\n  return class WithEvents extends Base implements IEventEmitter {\n    on(eventName: string | symbol, listener: (...args: any[]) => void, context?: any): this {\n      this.emitter.on(eventName, listener, context);\n      return this;\n    }\n\n    addListener(eventName: string | symbol, listener: (...args: any[]) => void, context?: any): this {\n      this.emitter.addListener(eventName, listener, context);\n      return this;\n    }\n\n    once(eventName: string | symbol, listener: (...args: any[]) => void, context?: any): this {\n      this.emitter.once(eventName, listener, context);\n      return this;\n    }\n\n    removeListener(eventName: string | symbol, listener: (...args: any[]) => void, context?: any): this {\n      this.emitter.removeListener(eventName, listener, context);\n      return this;\n    }\n\n    off(eventName: string | symbol, listener: (...args: any) => void, context?: any): this {\n      this.emitter.off(eventName, listener, context);\n      return this;\n    }\n\n    removeAllListeners(event?: string | symbol): this {\n      this.emitter.removeAllListeners(event);\n      return this;\n    }\n\n    listeners(eventName: string | symbol): Function[] {\n      return this.emitter.listeners(eventName);\n    }\n\n    emit(eventName: string | symbol, ...args: any[]): this  {\n      this.emitter.emit(eventName, args);\n      return this;\n    }\n\n    listenerCount(eventName: string | symbol): number {\n      return this.emitter.listenerCount(eventName);\n    }\n\n    prependListener(eventName: string | symbol, listener: (...args: any[]) => void, context?: any): this {\n      this.emitter.prependListener(eventName, listener, context);\n      return this;\n    }\n\n    prependOnceListener(eventName: string | symbol, listener: (...args: any[]) => void, context?: any): this {\n      this.emitter.prependOnceListener(eventName, listener, context);\n      return this;\n    }\n\n    eventNames(): (string | symbol)[] {\n      return this.emitter.eventNames();\n    }\n\n    maybeReportError (error: any): this {\n      this.emitter.maybeReportError(error);\n      return this;\n    }\n  };\n}","import { ILogger } from \"../logging/ILogger\";\nimport { IEventEmitter } from \"./IEventEmitter\";\n\ninterface Events {\n  [key: string | symbol]: {\n    handler: (...args: any[]) => void;\n    context: any;\n  }[];\n}\n\nexport class EventEmitter implements IEventEmitter {\n  private events: Events = {};\n\n  constructor(private logger?: ILogger) {}\n\n  private listeningTo (event: string) {\n    return !!this.events[event];\n  }\n\n  on (event: string | symbol, handler: (...args: any[]) => void, context?: any): this {\n    this.events[event] = this.events[event] || [];\n    this.events[event] = this.events[event].concat({\n      handler: handler,\n      context: context,\n    });\n\n    return this;\n  }\n\n  addListener (event: string | symbol, handler: (...args: any[]) => void, context?: any): this {\n    return this.on(event, handler, context);\n  }\n\n  once (event: string | symbol, handler: (...args: any[]) => void, context?: any): this {\n    const onceHandler = (...args: any[]) => {\n      this.off(event, onceHandler, context);\n      handler.apply(context, args);\n    };\n    return this.on(event, onceHandler, context);\n  }\n\n  off (event: string | symbol, handler: (...args: any[]) => void, context?: any): this {\n    if (!this.events[event]) {\n      return this;\n    }\n    for (let i = 0; i < this.events[event].length; i++) {\n      if (this.events[event][i].handler === handler && this.events[event][i].context === context) {\n        this.events[event] = this.events[event].slice(0, i).concat(this.events[event].slice(i + 1));\n      }\n    }\n\n    return this;\n  }\n\n  removeListener (event: string | symbol, handler: (...args: any[]) => void, context?: any): this {\n    return this.off(event, handler, context);\n  }\n\n  removeAllListeners (event?: string | symbol): this {\n    if (event) {\n      delete this.events[event];\n    } else {\n      this.events = {};\n    }\n\n    return this;\n  }\n\n  listeners (event: string | symbol): Function[] {\n    return this.events[event] ? this.events[event].map((event) => event.handler) : [];\n  }\n\n  emit (event: string | symbol, ...args: any[]): this {\n    if (!this.events[event]) {\n      return this;\n    }\n    // Copy the list of handlers before iterating, in case any handler adds or removes another handler.\n    // Any such changes should not affect what we do here-- we want to notify every handler that existed\n    // at the moment that the event was fired.\n    const copiedHandlers = [...this.events[event]];\n    for (let i = 0; i < copiedHandlers.length; i++) {\n      copiedHandlers[i].handler.apply(copiedHandlers[i].context, Array.prototype.slice.call(arguments, 1));\n    }\n\n    return this;\n  }\n\n  listenerCount (event: string | symbol): number {\n    return this.events[event] ? this.events[event].length : 0;\n  }\n\n  prependListener (event: string | symbol, handler: (...args: any[]) => void, context?: any): this {\n    this.events[event] = this.events[event] || [];\n    this.events[event] = [\n      {\n        handler: handler,\n        context: context,\n      },\n      ...this.events[event]\n    ];\n\n    return this;\n  }\n\n  prependOnceListener (event: string | symbol, handler: (...args: any[]) => void, context?: any): this {\n    const onceHandler = (...args: any[]) => {\n      this.off(event, onceHandler, context);\n      handler.apply(context, args);\n    };\n    return this.prependListener(event, onceHandler, context);\n  }\n\n  eventNames (): (string | symbol)[] {\n    return Object.keys(this.events);\n  }\n\n  maybeReportError (error: any): this {\n    if (!error) {\n      return this;\n    }\n    if (this.listeningTo('error')) {\n      this.emit('error', error);\n    } else {\n      this.logger?.error(error);\n    }\n\n    return this;\n  }\n}","import { Regex } from \"./Regex\";\n\nexport interface IConvertResult<TValue> {\n  isSucceeded: boolean,\n  value?: TValue\n}\n\nexport class ValueConverters {\n  static bool(value: string): IConvertResult<boolean> {\n    if (value?.toUpperCase() === 'TRUE') {\n      return ValueConverters.success<boolean>(true);\n    }\n\n    if (value?.toUpperCase() === 'FALSE') {\n      return ValueConverters.success<boolean>(false);\n    }\n\n    return ValueConverters.error<boolean>();\n  }\n\n  static number(value: string): IConvertResult<number> {\n    const num = Number(value);\n\n    if (Number.isNaN(num)) {\n      return ValueConverters.error<number>();\n    }\n\n    return ValueConverters.success<number>(num);\n  }\n\n  static string(value: string): IConvertResult<string> {\n    return ValueConverters.success<string>(value);\n  }\n\n  static json(value: string): IConvertResult<unknown> {\n    try {\n      const val = JSON.parse(value);\n      return ValueConverters.success<unknown>(val);\n    } catch (err) {\n      return ValueConverters.error<unknown>();\n    }\n  }\n\n  private static success<TValue>(value: TValue): IConvertResult<TValue> {\n    return {\n      isSucceeded: true,\n      value: value\n    }\n  }\n\n  private static error<TValue>(): IConvertResult<TValue> {\n    return {\n      isSucceeded: false\n    }\n  }\n}","// This function is designed to remove any trailing forward slashes at the end of the provided URI string\nexport function canonicalizeUri(uri: string): string {\n  return uri.replace(/\\/+$/, '');\n}","/**\n * Wait before calling the same function. Useful for expensive calls.\n * Adapted from https://amitd.co/code/typescript/debounce.\n *\n * @return The debounced function.\n *\n * @example\n *\n * ```js\n * const debouncedFunction = debounce(e => {\n *   console.log(e);\n * }, 5000);\n *\n * // Console logs 'Hello world again ' after 5 seconds\n * debouncedFunction('Hello world');\n * debouncedFunction('Hello world again');\n * ```\n * @param fn The function to be debounced.\n * @param delayMs Defaults to 5 seconds.\n */\nexport const debounce = <T extends (...args: any[]) => ReturnType<T>>(\n  fn: T,\n  delayMs: number = 5000,\n): ((...args: Parameters<T>) => void) => {\n  let timer: ReturnType<typeof setTimeout>;\n\n  return (...args: Parameters<T>) => {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn(...args);\n    }, delayMs);\n  };\n};\n","import { IInfo } from \"../platform/IInfo\";\n\nexport type Headers = {\n  Authorization: string;\n  'X-User-Agent': string;\n  'Content-Type': string;\n};\n\nexport function defaultHeaders(\n  sdkKey: string,\n  info: IInfo\n): Headers {\n  const {userAgent, version} = info.sdkData();\n\n  const headers: Headers = {\n    'Content-Type': 'application/json',\n    'X-User-Agent': userAgent ?? `${info.appType}/${version}`,\n    'Authorization': sdkKey\n  };\n\n  return headers;\n}\n\nexport function httpErrorMessage(\n  err: {\n    status: number;\n    message: string;\n  },\n  context: string,\n  retryMessage?: string,\n): string {\n  let desc;\n  if (err.status) {\n    desc = `error ${ err.status }${ err.status === 401 ? ' (invalid SDK key)' : '' }`;\n  } else {\n    desc = `I/O error (${ err.message || err })`;\n  }\n  const action = retryMessage ?? 'giving up permanently';\n  return `Received ${ desc } for ${ context } - ${ action }`;\n}\n","export * from './isNullOrUndefined';\nexport * from './sleep';\nexport * from './ValueConverters';\nexport * from './VoidFunction';\nexport * from './serializeUser';\nexport * from './debounce';","export function isNullOrUndefined(val: any) {\n  return val === null || val === undefined;\n}","import { IUser } from \"../options/IUser\";\n\nexport function serializeUser(user: IUser | undefined): string {\n  if (!user) {\n    return '';\n  }\n\n  const builtInProperties = `${user.keyId},${user.name}`;\n\n  const customizedProperties = user.customizedProperties\n    ?.sort((a, b) => {\n      const nameA = a.name.toLowerCase();\n      const nameB = b.name.toLowerCase();\n      if (nameA < nameB) {\n        return -1;\n      }\n\n      if (nameA > nameB) {\n        return 1;\n      }\n\n      return 0;\n    })\n    .map(p => `${p.name}:${p.value}`)\n    .join(',');\n\n  return `${builtInProperties},${customizedProperties}`;\n}","const sleep = async (delayMillis: number = 1000) =>\n  new Promise((resolve) => {\n    setTimeout(resolve, delayMillis);\n  });\n\nexport default sleep;","export const version = \"3.0.12\"; export const name = \"@featbit/js-client-sdk\";\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(9872);\n"],"names":["root","factory","exports","module","define","amd","a","i","this","validations","startWaitTime","TypeValidators","Number","sdkKey","String","pollingUri","streamingUri","eventsUri","webSocketPingInterval","logger","Object","store","ObjectOrFactory","dataSynchronizer","flushInterval","maxEventsInQueue","pollingInterval","offline","Boolean","dataSyncMode","bootstrap","Bootstrap","user","User","defaultValues","DataSyncModeEnum","STREAMING","sendEvents","options","undefined","constructor","bootstrapProvider","NullBootstrapProvider","errors","validatedOptions","keys","forEach","optionName","optionValue","validator","is","getType","push","wrongOptionTypeBoolean","NumberWithMinimum","min","optionBelowMinimum","UserValidator","messages","wrongOptionType","warn","unknownOption","validateTypesAndNames","error","streamingUriMissing","isNullOrUndefined","EmptyString","pollingUriMissing","eventsUriMissing","partialEndpoint","POLLING","validateEndpoints","canonicalizeUri","length","JsonBootstrapProvider","_","info","Function","dataSynchronizerFactory","storeFactory","Context","valid","message","fromUser","contextForError","keyId","name","trim","context","_user","value","property","customizedProperties","find","x","_options","build","_platform","platform","mode","flags","ClientState","callbacks","state","Initializing","onError","onFailed","onReady","onUpdate","hasEventListeners","config","Error","init","clientContext","identify","dataSourceUpdates","evaluator","populate","eventProcessor","NullEventProcessor","NullDataSynchronizer","initSuccess","DefaultEventProcessor","listeners","createStreamListeners","put","patch","webSocket","version","requests","e","dataSourceErrorHandler","start","oldFlags","oldVersion","all","Flags","oldData","newFlags","newVersion","newData","checkUpdates","setTimeout","initialized","msg","TimeoutError","Failed","rejectionReason","initReject","Initialized","waitForInitialization","initializedPromise","Promise","resolve","reject","initResolve","boolVariation","key","defaultValue","evaluateCore","ValueConverters","bool","boolVariationDetail","jsonVariation","json","jsonVariationDetail","numberVariation","number","numberVariationDetail","stringVariation","string","stringVariationDetail","variation","variationDetail","getAllVariations","ClientError","result","map","flagKey","evalResult","evaluate","kind","reason","close","track","eventName","metricValue","metricEvent","MetricEvent","appType","record","flush","callback","err","typeConverter","ReasonKinds","FlagNotFound","toEvalEvent","isSucceeded","WrongType","code","flag","variationOptions","id","data","deserializeAll","dataSet","userKeyId","MinInt","onChange","allData","checkForChanges","doInit","then","updatedKeys","flatMap","namespace","oldDataForKind","newDataForKind","mergedData","filter","isUpdated","upsert","doUpsert","oldItem","get","createPutListener","onPutCompleteHandler","deserializeData","processJson","initData","debug","createPatchListener","onPatchCompleteHandler","deserializePatch","item","onCompleteHandlers","Map","set","stop","requestor","getStoreTimestamp","errorHandler","stopped","poll","startTime","Date","now","requestData","body","elapsed","sleepFor","Math","max","status","isHttpRecoverable","httpErrorMessage","PollingError","featureFlags","processStreamResponse","JSON","parse","messageType","eventType","StreamResponseEventType","full","timeoutHandle","clearTimeout","headers","defaultHeaders","uri","request","requestUrl","res","fetch","text","timestamp","payload","cb","method","stringify","StreamingError","socket","pingInterval","addListener","event","logConnectionStarted","connect","connectionAttemptStartTime","alphabet","encodeNumber","param","s","slice","split","n","join","replace","timestampCode","toString","floor","random","super","UnexpectedResponseError","EvalResult","flagNotFound","matched","val","Match","targetedVariation","variations","v","EvalEvent","sendToExperiment","VariationDataType","closed","eventQueue","DefaultEventQueue","eventDispatcher","EventDispatcher","flushLoop","flushEvent","FlushEvent","waitForCompletion","shutdown","ShutdownEvent","addEvent","complete","capacity","events","clear","shift","eventsSnapshot","isEmpty","send","retry","DeliveryStatus","Succeeded","FailedAndMustShutDown","serialize","toPayload","queue","maxEventPerRequest","buffer","sender","DefaultEventSender","serializer","DefaultEventSerializer","dispatchLoop","running","PayloadEvent","addEventToBuffer","triggerFlush","snapshot","flushEvents","total","getUniqueEvents","uniqueEvents","hashes","includes","hash","AsyncEvent","getTime","isCompletedPromise","resolveFn","userPayload","metrics","route","numericValue","type","hasObject","m","featureFlagKey","LogPriority","none","LevelNames","BasicLogger","logLevel","level","destination","formatter","tryFormat","args","tryWrite","console","log","prefix","loggerRequirements","fallback","entries","tryStringify","prototype","hasOwnProperty","call","TypeError","indexOf","escapes","d","toNumber","parseInt","toInt","f","parseFloat","toFloat","j","o","O","c","formatString","out","char","charAt","nextChar","configuration","expectedType","actualType","mandatory","invalidOptionValue","missingKeyInBootstrapValue","_keyId","_name","_custom","custom","propertyName","FactoryOrInstance","factoryOrInstance","Array","isArray","typeOfFactory","Type","typeName","example","typeOf","u","TypeArray","every","StringMatchingRegex","expression","match","NullableBoolean","DATE_REGEX","DateValidator","test","KindValidator","createTypeArray","numberWithMin","stringMatchingRegex","StringArray","Kind","platformData","os","additional","sdkData","userAgent","BrowserRequests","url","socketConnectionIntervals","Emits","retryCounter","_config","emitter","EventEmitter","doDataSync","that","generateConnectionToken","ws","WebSocket","addEventListener","sendPingMessage","reconnect","emit","readyState","OPEN","waitTime","FbClient","FbClientCore","fallbackLogger","SafeLogger","BrowserPlatform","listenerCount","eventNames","some","startsWith","LocalStorageStore","BaseStore","description","saveUser","localStorage","setItem","CurrentUserStorageKey","serializeUser","dumpStoreToStorage","storageKey","StoreStorageKey","loadStoreFromStorage","dataStoreStr","getItem","BrowserWebSocket","initCalled","addItem","items","old","ele","DataKinds","InMemoryStore","allStores","reduce","acc","cur","Base","on","listener","once","removeListener","off","removeAllListeners","prependListener","prependOnceListener","maybeReportError","listeningTo","handler","concat","onceHandler","apply","copiedHandlers","arguments","toUpperCase","success","num","isNaN","debounce","fn","delayMs","timer","retryMessage","desc","sort","b","nameA","toLowerCase","nameB","p","delayMillis","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}